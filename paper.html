<div data-v-50613151=""><div id="section-analysis" class="paper-section" data-v-50613151=""><h2 class="paper-section__title"><span class="paper-section__accent" aria-hidden="true"></span><span>中文精读</span><span class="paper-section__meta">约 30 分钟读完 · 16,550 字</span></h2><div data-v-e9139ffe="" class="markdown-with-toc space-y-4 min-w-0 paper-section__body"><div data-v-e9139ffe="" class="md:hidden"><button data-v-e9139ffe="" type="button" class="w-full flex items-center justify-between gap-2 rounded-lg border theme-border bg-[color:var(--bg)]/95 px-4 py-2 text-sm font-medium transition-colors hover:bg-[color:var(--bg-soft)]" aria-expanded="false" aria-controls="v-0-1"><span data-v-e9139ffe="">内容目录</span><span data-v-e9139ffe="" class="flex items-center gap-2 text-xs uppercase tracking-[0.12em]">展开目录 <i data-v-e9139ffe="" class="fa-solid fa-chevron-down" aria-hidden="true"></i></span></button><!----></div><div data-v-e9139ffe="" class="prose dark:prose-invert max-w-none"><h1 id="1-论文基本信息" tabindex="-1">1. 论文基本信息</h1>
<h2 id="11-标题" tabindex="-1">1.1. 标题</h2>
<p id="para-11-标题-1" data-para-index="1" data-para-heading="11-标题" data-para-heading-title="1.1. 标题">Kgent: Kernel Extensions Large Language Model Agent (KGeNT：内核扩展大语言模型智能体)</p>
<h2 id="12-作者" tabindex="-1">1.2. 作者</h2>
<ul>
<li id="para-12-作者-1" data-para-index="1" data-para-heading="12-作者" data-para-heading-title="1.2. 作者" data-para-sub-title="YUSHENG ZHENG (郑宇生)" data-para-sub-slug="yusheng-zheng-郑宇生" data-para-alias="para-12-作者--yusheng-zheng-郑宇生"><span id="para-12-作者--yusheng-zheng-郑宇生" data-anchor-alias="para-12-作者-1" style="position: relative; top: 0px;"></span><strong>YUSHENG ZHENG (郑宇生)</strong>: 伦敦帝国学院 (Imperial College London)，英国伦敦。</li>
<li id="para-12-作者-2" data-para-index="2" data-para-heading="12-作者" data-para-heading-title="1.2. 作者" data-para-sub-title="YIWEI YANG (杨毅伟)" data-para-sub-slug="yiwei-yang-杨毅伟" data-para-alias="para-12-作者--yiwei-yang-杨毅伟"><span id="para-12-作者--yiwei-yang-杨毅伟" data-anchor-alias="para-12-作者-2" style="position: relative; top: 0px;"></span><strong>YIWEI YANG (杨毅伟)</strong>: 加州大学圣克鲁兹分校 (University of California, Santa Cruz)，美国加利福尼亚州圣克鲁兹。</li>
<li id="para-12-作者-3" data-para-index="3" data-para-heading="12-作者" data-para-heading-title="1.2. 作者" data-para-sub-title="MAOLIN CHEN (陈茂林)" data-para-sub-slug="maolin-chen-陈茂林" data-para-alias="para-12-作者--maolin-chen-陈茂林"><span id="para-12-作者--maolin-chen-陈茂林" data-anchor-alias="para-12-作者-3" style="position: relative; top: 0px;"></span><strong>MAOLIN CHEN (陈茂林)</strong>: eunomia-bpf 社区，中国上海。</li>
<li id="para-12-作者-4" data-para-index="4" data-para-heading="12-作者" data-para-heading-title="1.2. 作者" data-para-sub-title="ANDREW QUINN" data-para-sub-slug="andrew-quinn" data-para-alias="para-12-作者--andrew-quinn"><span id="para-12-作者--andrew-quinn" data-anchor-alias="para-12-作者-4" style="position: relative; top: 0px;"></span><strong>ANDREW QUINN</strong>: 加州大学圣克鲁兹分校 (University of California, Santa Cruz)，美国加利福尼亚州圣克鲁兹。</li>
</ul>
<h2 id="13-发表期刊会议" tabindex="-1">1.3. 发表期刊/会议</h2>
<p id="para-13-发表期刊会议-1" data-para-index="1" data-para-heading="13-发表期刊会议" data-para-heading-title="1.3. 发表期刊/会议">ACM SIGCOMM '24: ACM SIGCOMM 2024 Conference (ACM SIGCOMM '24: ACM SIGCOMM 2024 大会)。
SIGCOMM 是计算机网络领域的顶级国际会议，享有极高的声誉和影响力。</p>
<h2 id="14-发表年份" tabindex="-1">1.4. 发表年份</h2>
<p id="para-14-发表年份-1" data-para-index="1" data-para-heading="14-发表年份" data-para-heading-title="1.4. 发表年份">2024年8月4日（发表），2026年1月22日（总引用/下载数据更新）。</p>
<h2 id="15-摘要" tabindex="-1">1.5. 摘要</h2>
<p id="para-15-摘要-1" data-para-index="1" data-para-heading="15-摘要" data-para-heading-title="1.5. 摘要">扩展的 Berkeley Packet Filters (eBPF) 生态系统允许扩展 Linux 和 Windows 内核，但编写 eBPF 程序具有挑战性，因为它需要操作系统内部知识和 eBPF 验证器 (eBPF verifier) 强制的编程限制。这些限制使得只有专业的内核开发人员才能扩展其内核，这让初级系统管理员、补丁开发者和 DevOps 人员难以维护扩展。本文提出了 KGeNT，一个替代框架，通过允许使用<strong>自然语言 (Natural language)</strong> 编写<strong>内核扩展 (Kernel Extensions)</strong> 来减轻编写 eBPF 程序的难度。KGeNT 利用<strong>大语言模型 (Large Language Models, LLMs)</strong> 的最新进展，根据用户的英语提示<strong>合成 (synthesize)</strong> eBPF 程序。为了确保 LLM 的输出与用户提示在<strong>语义上等价 (semantically equivalent)</strong>，KGeNT 采用了 <strong>LLM 赋能的程序理解 (LLM-empowered program comprehension)</strong>、<strong>符号执行 (symbolic execution)</strong> 和一系列<strong>反馈循环 (feedback loops)</strong> 的组合。KGeNT 的关键创新在于这些技术的结合。特别是，该系统以一种新颖的结构使用符号执行，使其能够结合程序合成和程序理解的结果，并建立在 LLMs 在这些任务中分别取得的最新成功之上。为了评估 KGeNT，作者开发了一个新的 eBPF 程序自然语言提示语料库。实验表明，KGeNT 能够生成 80% 的正确 eBPF 程序，与 GPT-4 程序合成基线相比，这是一个 2.67 倍的改进。此外，作者发现 KGeNT 很少合成“<strong>假阳性 (false positive)</strong>” eBPF 程序——即 KGeNT 验证为正确但手动检查发现与输入提示在语义上不正确的 eBPF 程序。KGeNT 的代码已在 GitHub 上公开。</p>
<h2 id="16-原文链接" tabindex="-1">1.6. 原文链接</h2>
<p id="para-16-原文链接-1" data-para-index="1" data-para-heading="16-原文链接" data-para-heading-title="1.6. 原文链接">论文 PDF 链接: /files/papers/6971fc30cfa1aabed60f2ed8/paper.pdf
GitHub 链接: <code>https://github.com/eunomiabpf/KEN</code>
发表状态：已正式发表于 ACM SIGCOMM '24 会议。</p>
<h1 id="2-整体概括" tabindex="-1">2. 整体概括</h1>
<h2 id="21-研究背景与动机" tabindex="-1">2.1. 研究背景与动机</h2>
<ul>
<li id="para-21-研究背景与动机-1" data-para-index="1" data-para-heading="21-研究背景与动机" data-para-heading-title="2.1. 研究背景与动机" data-para-sub-title="核心问题" data-para-sub-slug="核心问题" data-para-alias="para-21-研究背景与动机--核心问题"><span id="para-21-研究背景与动机--核心问题" data-anchor-alias="para-21-研究背景与动机-1" style="position: relative; top: 0px;"></span><strong>核心问题</strong>: 开发者在修改和扩展操作系统内核以提升性能、安全性、可靠性或引入新功能时，越来越多地依赖 <code>eBPF (extended Berkeley Packet Filters)</code>。<code>eBPF</code> 已成为扩展操作系统的事实标准，并获得了 Linux 和 Windows 的支持。然而，编写正确的 <code>eBPF</code> 程序非常困难。它要求开发者具备<strong>深刻的内核内部知识 (intimate knowledge of kernel internals)</strong>，以确定逻辑注入点。此外，<code>eBPF</code> 验证器 (eBPF verifier) 为了防止不安全的 <code>eBPF</code> 程序在系统上执行，对 <code>eBPF</code> 程序员施加了严格的编程限制，例如，循环必须有常量边界，不能访问任意内存，这使得 <code>eBPF</code> 并非图灵完备语言。</li>
<li id="para-21-研究背景与动机-2" data-para-index="2" data-para-heading="21-研究背景与动机" data-para-heading-title="2.1. 研究背景与动机" data-para-sub-title="重要性" data-para-sub-slug="重要性" data-para-alias="para-21-研究背景与动机--重要性"><span id="para-21-研究背景与动机--重要性" data-anchor-alias="para-21-研究背景与动机-2" style="position: relative; top: 0px;"></span><strong>重要性</strong>: 这种高门槛导致只有专家级内核开发者才能有效利用 <code>eBPF</code>，使得初级系统管理员、补丁开发者和 DevOps 人员难以维护和扩展内核功能，从而限制了 <code>eBPF</code> 的普及和应用。</li>
<li id="para-21-研究背景与动机-3" data-para-index="3" data-para-heading="21-研究背景与动机" data-para-heading-title="2.1. 研究背景与动机" data-para-sub-title="切入点/创新思路" data-para-sub-slug="切入点创新思路" data-para-alias="para-21-研究背景与动机--切入点创新思路"><span id="para-21-研究背景与动机--切入点创新思路" data-anchor-alias="para-21-研究背景与动机-3" style="position: relative; top: 0px;"></span><strong>切入点/创新思路</strong>: 论文旨在通过引入 <strong>KGeNT (Kernel Extensions LLM Agent)</strong> 框架来解决这一痛点。KGeNT 的核心思想是允许用户使用<strong>自然语言 (Natural language)</strong> 来描述所需的内核扩展功能，然后利用<strong>大语言模型 (LLMs)</strong> 自动合成相应的 <code>eBPF</code> 程序。为了确保合成程序的正确性，KGeNT 结合了 LLM 驱动的程序理解、<strong>符号执行 (symbolic execution)</strong> 和<strong>反馈循环 (feedback loops)</strong> 进行验证。</li>
</ul>
<h2 id="22-核心贡献主要发现" tabindex="-1">2.2. 核心贡献/主要发现</h2>
<ul>
<li id="para-22-核心贡献主要发现-1" data-para-index="1" data-para-heading="22-核心贡献主要发现" data-para-heading-title="2.2. 核心贡献/主要发现" data-para-sub-title="主要贡献" data-para-sub-slug="主要贡献" data-para-alias="para-22-核心贡献主要发现--主要贡献"><span id="para-22-核心贡献主要发现--主要贡献" data-anchor-alias="para-22-核心贡献主要发现-1" style="position: relative; top: 0px;"></span><strong>主要贡献</strong>:
<ul>
<li id="para-22-核心贡献主要发现-2" data-para-index="2" data-para-heading="22-核心贡献主要发现" data-para-heading-title="2.2. 核心贡献/主要发现" data-para-sub-title="KGeNT 框架" data-para-sub-slug="kgent-框架" data-para-alias="para-22-核心贡献主要发现--kgent-框架"><span id="para-22-核心贡献主要发现--kgent-框架" data-anchor-alias="para-22-核心贡献主要发现-2" style="position: relative; top: 0px;"></span>提出了 <strong>KGeNT 框架</strong>，一个新颖的系统，它将 <strong>LLM 赋能的程序合成 (LLM-empowered program synthesis)</strong>、<strong>程序理解 (program comprehension)</strong>、<strong>符号执行 (symbolic execution)</strong> 和<strong>反馈机制 (feedback mechanisms)</strong> 结合起来，以自然语言生成和验证 <code>eBPF</code> 程序。其关键创新在于将这些技术融合为一个高效且实用的程序合成工具，特别是利用符号执行来桥接程序合成和程序理解的成果。</li>
<li id="para-22-核心贡献主要发现-3" data-para-index="3" data-para-heading="22-核心贡献主要发现" data-para-heading-title="2.2. 核心贡献/主要发现" data-para-sub-title="EBPFNLDATAsET" data-para-sub-slug="ebpfnldataset" data-para-alias="para-22-核心贡献主要发现--ebpfnldataset"><span id="para-22-核心贡献主要发现--ebpfnldataset" data-anchor-alias="para-22-核心贡献主要发现-3" style="position: relative; top: 0px;"></span>开发了两个新的数据集：<strong>EBPFNLDATAsET</strong>，一个包含自然语言提示和对应 <code>eBPF</code> 程序的语料库，用于训练和评估 <code>eBPF</code> 程序合成；以及 <strong>KERNELCoMPDATAsET</strong>，一个通过自动化方法生成的核心函数 Hoare 逻辑契约数据集，用于程序理解。</li>
</ul>
</li>
<li id="para-22-核心贡献主要发现-4" data-para-index="4" data-para-heading="22-核心贡献主要发现" data-para-heading-title="2.2. 核心贡献/主要发现" data-para-sub-title="关键结论/发现" data-para-sub-slug="关键结论发现" data-para-alias="para-22-核心贡献主要发现--关键结论发现"><span id="para-22-核心贡献主要发现--关键结论发现" data-anchor-alias="para-22-核心贡献主要发现-4" style="position: relative; top: 0px;"></span><strong>关键结论/发现</strong>:
<ul>
<li id="para-22-核心贡献主要发现-5" data-para-index="5" data-para-heading="22-核心贡献主要发现" data-para-heading-title="2.2. 核心贡献/主要发现">KGeNT 在其新建的 <code>eBPF</code> 程序自然语言提示语料库上实现了 <strong>80% 的正确性 (accuracy)</strong>，比基线 GPT-4 程序合成方法提高了 2.67 倍。</li>
<li id="para-22-核心贡献主要发现-6" data-para-index="6" data-para-heading="22-核心贡献主要发现" data-para-heading-title="2.2. 核心贡献/主要发现" data-para-sub-title="假阳性 (false positive)" data-para-sub-slug="假阳性-false-positive" data-para-alias="para-22-核心贡献主要发现--假阳性-false-positive"><span id="para-22-核心贡献主要发现--假阳性-false-positive" data-anchor-alias="para-22-核心贡献主要发现-6" style="position: relative; top: 0px;"></span>KGeNT 极少生成<strong>假阳性 (false positive)</strong> <code>eBPF</code> 程序（即 KGeNT 验证为正确但实际语义不符的程序），其假阳性率仅为 2.5%，这对于内核扩展的安全性至关重要。</li>
<li id="para-22-核心贡献主要发现-7" data-para-index="7" data-para-heading="22-核心贡献主要发现" data-para-heading-title="2.2. 核心贡献/主要发现" data-para-sub-title="模型引导的反馈 (model-guided feedback)" data-para-sub-slug="模型引导的反馈-model-guided-feedback" data-para-alias="para-22-核心贡献主要发现--模型引导的反馈-model-guided-feedback"><span id="para-22-核心贡献主要发现--模型引导的反馈-model-guided-feedback" data-anchor-alias="para-22-核心贡献主要发现-7" style="position: relative; top: 0px;"></span><strong>模型引导的反馈 (model-guided feedback)</strong> 和 <strong>理解引擎 (Comprehension Engine)</strong> 与<strong>符号执行 (Symbolic Execution)</strong> 组件在显著提高 KGeNT 的准确性方面发挥了关键作用。</li>
<li id="para-22-核心贡献主要发现-8" data-para-index="8" data-para-heading="22-核心贡献主要发现" data-para-heading-title="2.2. 核心贡献/主要发现"><code>bpftrace</code> 作为 <code>eBPF</code> 程序的合成目标比 <code>libbpf</code> 更有效，因为 <code>libbpf</code> 的复杂性导致符号执行引擎在处理时经常超时。</li>
</ul>
</li>
</ul>
<h1 id="3-预备知识与相关工作" tabindex="-1">3. 预备知识与相关工作</h1>
<h2 id="31-基础概念" tabindex="-1">3.1. 基础概念</h2>
<ul>
<li id="para-31-基础概念-1" data-para-index="1" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="扩展的 Berkeley Packet Filters (eBPF)" data-para-sub-slug="扩展的-berkeley-packet-filters-ebpf" data-para-alias="para-31-基础概念--扩展的-berkeley-packet-filters-ebpf"><span id="para-31-基础概念--扩展的-berkeley-packet-filters-ebpf" data-anchor-alias="para-31-基础概念-1" style="position: relative; top: 0px;"></span><strong>扩展的 Berkeley Packet Filters (eBPF)</strong>: <code>eBPF</code> 是一种在 Linux 和 Windows 内核中执行用户定义程序的强大技术。它允许开发者在不修改内核源代码的情况下，将自定义逻辑注入到内核的特定<strong>钩子点 (hook points)</strong>（如网络事件、系统调用、函数入口/出口）中，以实现性能监控、安全审计、网络流量处理、自定义调度等功能。<code>eBPF</code> 程序在内核空间运行，但在一个受限的虚拟机环境中，并通过一个<strong>验证器 (verifier)</strong> 确保其安全性（例如，无无限循环、无非法内存访问），防止其崩溃内核。然而，这种安全性限制也使得编写 <code>eBPF</code> 程序需要深入理解内核内部机制和严格的编程规约。</li>
<li id="para-31-基础概念-2" data-para-index="2" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="大语言模型 (Large Language Models, LLMs)" data-para-sub-slug="大语言模型-large-language-models-llms" data-para-alias="para-31-基础概念--大语言模型-large-language-models-llms"><span id="para-31-基础概念--大语言模型-large-language-models-llms" data-anchor-alias="para-31-基础概念-2" style="position: relative; top: 0px;"></span><strong>大语言模型 (Large Language Models, LLMs)</strong>: <code>LLM</code> 是一种基于<strong>深度学习 (deep learning)</strong> 的人工智能模型，通过在海量文本数据上进行训练，学习语言的模式、语法和语义。它们能够生成、理解和处理自然语言文本，并能执行各种任务，如文本摘要、翻译、问答，以及在本研究中关键的<strong>代码生成 (code generation)</strong> 和<strong>代码理解 (code comprehension)</strong>。</li>
<li id="para-31-基础概念-3" data-para-index="3" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="少样本上下文学习 (Few-shot In-Context Learning)" data-para-sub-slug="少样本上下文学习-few-shot-in-context-learning" data-para-alias="para-31-基础概念--少样本上下文学习-few-shot-in-context-learning"><span id="para-31-基础概念--少样本上下文学习-few-shot-in-context-learning" data-anchor-alias="para-31-基础概念-3" style="position: relative; top: 0px;"></span><strong>少样本上下文学习 (Few-shot In-Context Learning)</strong>: <code>LLM</code> 的一种应用模式。它通过在给 <code>LLM</code> 的<strong>提示 (prompt)</strong> 中提供少量相关的输入-输出示例（“少样本”），而不是对模型进行传统的<strong>微调 (fine-tuning)</strong>，来使其适应新的任务或领域。这种方法成本效益高，且能快速适应新数据。在程序合成中，这意味着给 <code>LLM</code> 看到一些自然语言提示和对应代码的例子，以引导其生成类似的代码。</li>
<li id="para-31-基础概念-4" data-para-index="4" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="反馈循环 (Feedback Loops)" data-para-sub-slug="反馈循环-feedback-loops" data-para-alias="para-31-基础概念--反馈循环-feedback-loops"><span id="para-31-基础概念--反馈循环-feedback-loops" data-anchor-alias="para-31-基础概念-4" style="position: relative; top: 0px;"></span><strong>反馈循环 (Feedback Loops)</strong>: 在软件工程和人工智能中，反馈循环是一种机制，用于根据系统的输出或行为来调整或优化其输入或内部状态。在 <code>LLM</code> 应用中，它通常用于验证 <code>LLM</code> 生成的输出是否符合某种规范，并将验证结果（如错误消息）反馈给模型，让其迭代地修正输出，直到达到目标。</li>
<li id="para-31-基础概念-5" data-para-index="5" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="自动化程序理解 (Automated Program Comprehension)" data-para-sub-slug="自动化程序理解-automated-program-comprehension" data-para-alias="para-31-基础概念--自动化程序理解-automated-program-comprehension"><span id="para-31-基础概念--自动化程序理解-automated-program-comprehension" data-anchor-alias="para-31-基础概念-5" style="position: relative; top: 0px;"></span><strong>自动化程序理解 (Automated Program Comprehension)</strong>: 指无需开发者手动干预，自动分析程序以确定其属性、行为和意图的技术。传统方法包括<strong>反例驱动 (counter-example driven)</strong> 的<strong>不变量 (invariants)</strong> 推导。近期研究表明，<code>LLM</code> 在从代码生成自然语言描述或识别代码属性方面表现出色。</li>
<li id="para-31-基础概念-6" data-para-index="6" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="符号执行 (Symbolic Execution, Symbex)" data-para-sub-slug="符号执行-symbolic-execution-symbex" data-para-alias="para-31-基础概念--符号执行-symbolic-execution-symbex"><span id="para-31-基础概念--符号执行-symbolic-execution-symbex" data-anchor-alias="para-31-基础概念-6" style="position: relative; top: 0px;"></span><strong>符号执行 (Symbolic Execution, Symbex)</strong>: 一种程序分析技术，用于验证程序的正确性或查找错误。它不使用具体的输入值执行程序，而是使用<strong>符号值 (symbolic values)</strong> 来表示输入。当程序执行时，<code>Symbex</code> 引擎会收集关于这些符号值的<strong>约束条件 (constraints)</strong>。然后，它利用 <strong>SMT 求解器 (Satisfiability Modulo Theories solver)</strong> 来检查在这些约束条件下，程序是否可能违反某个属性（例如，内存安全、断言是否成立）。通过这种方式，<code>Symbex</code> 能够推理程序在大量可能输入下的行为，而无需逐一执行每个输入。</li>
<li id="para-31-基础概念-7" data-para-index="7" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="Hoare 逻辑 (Hoare Logic)" data-para-sub-slug="hoare-逻辑-hoare-logic" data-para-alias="para-31-基础概念--hoare-逻辑-hoare-logic"><span id="para-31-基础概念--hoare-逻辑-hoare-logic" data-anchor-alias="para-31-基础概念-7" style="position: relative; top: 0px;"></span><strong>Hoare 逻辑 (Hoare Logic)</strong>: 一种用于程序形式化验证的逻辑系统。它通过<strong>霍尔三元组 (Hoare Triple)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>P</mi><mo stretchy="false">}</mo><mi>C</mi><mo stretchy="false">{</mo><mi>Q</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P\} C \{Q\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">}</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">{</span><span class="mord mathnormal">Q</span><span class="mclose">}</span></span></span></span> 来描述程序行为，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 是<strong>前置条件 (pre-condition)</strong>，表示在程序 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 执行前必须满足的条件；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 是程序代码；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> 是<strong>后置条件 (post-condition)</strong>，表示在程序 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 成功执行后保证满足的条件。通过验证这些条件，可以证明程序的正确性。</li>
<li id="para-31-基础概念-8" data-para-index="8" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="bpftrace" data-para-sub-slug="bpftrace" data-para-alias="para-31-基础概念--bpftrace"><span id="para-31-基础概念--bpftrace" data-anchor-alias="para-31-基础概念-8" style="position: relative; top: 0px;"></span><strong>bpftrace</strong>: 一种用于 Linux <code>eBPF</code> 的高级追踪语言。它提供了一种简洁的语法来编写 <code>eBPF</code> 程序，可以轻松地追踪内核和用户空间的事件，并打印出所需的信息。它比直接编写 <code>eBPF</code> C 代码更易于使用，但功能可能受限。</li>
<li id="para-31-基础概念-9" data-para-index="9" data-para-heading="31-基础概念" data-para-heading-title="3.1. 基础概念" data-para-sub-title="libbpf" data-para-sub-slug="libbpf" data-para-alias="para-31-基础概念--libbpf"><span id="para-31-基础概念--libbpf" data-anchor-alias="para-31-基础概念-9" style="position: relative; top: 0px;"></span><strong>libbpf</strong>: 一个用于开发 <code>eBPF</code> 程序的 C/C++ 库。它提供了更底层、更灵活的 <code>eBPF</code> 程序开发接口，允许开发者完全控制 <code>eBPF</code> 程序的生命周期、映射操作和事件处理，但编程复杂性更高。</li>
</ul>
<h2 id="32-前人工作" tabindex="-1">3.2. 前人工作</h2>
<ul>
<li id="para-32-前人工作-1" data-para-index="1" data-para-heading="32-前人工作" data-para-heading-title="3.2. 前人工作" data-para-sub-title="LLM 在程序理解任务中的应用" data-para-sub-slug="llm-在程序理解任务中的应用" data-para-alias="para-32-前人工作--llm-在程序理解任务中的应用"><span id="para-32-前人工作--llm-在程序理解任务中的应用" data-anchor-alias="para-32-前人工作-1" style="position: relative; top: 0px;"></span><strong><code>LLM</code> 在程序理解任务中的应用</strong>: 论文提及了多项研究 ([1, 12, 13, 25, 34, 38]) 表明 <code>LLM</code> 在程序理解任务中的有效性。这些工作通常侧重于从代码生成自然语言描述（如代码摘要）、识别代码属性或进行代码到代码的转换。例如，<code>CodeBERT</code> ([13]) 等预训练模型已经展示了在程序和自然语言之间建立关联的能力，这为 <code>LLM</code> 进行程序理解奠定了基础。</li>
<li id="para-32-前人工作-2" data-para-index="2" data-para-heading="32-前人工作" data-para-heading-title="3.2. 前人工作" data-para-sub-title="反馈驱动的 LLM 输出验证" data-para-sub-slug="反馈驱动的-llm-输出验证" data-para-alias="para-32-前人工作--反馈驱动的-llm-输出验证"><span id="para-32-前人工作--反馈驱动的-llm-输出验证" data-anchor-alias="para-32-前人工作-2" style="position: relative; top: 0px;"></span><strong>反馈驱动的 <code>LLM</code> 输出验证</strong>: 论文引用了 <code>HarmonyOS</code> 开发者 ([33]) 和 <code>TPUv4</code> 设计者 ([29]) 使用单元测试来评估 <code>LLM</code> 输出的正确性的方法。<code>SELF-DEBugGING</code> ([5]) 则通过 <code>LLM</code> 解释合成程序的行为、检查单元测试输出，然后迭代地重新合成来细化输出。这些工作强调了在 <code>LLM</code> 生成的代码中，验证和迭代修正的重要性。</li>
<li id="para-32-前人工作-3" data-para-index="3" data-para-heading="32-前人工作" data-para-heading-title="3.2. 前人工作" data-para-sub-title="符号执行在操作系统和用户程序中的应用" data-para-sub-slug="符号执行在操作系统和用户程序中的应用" data-para-alias="para-32-前人工作--符号执行在操作系统和用户程序中的应用"><span id="para-32-前人工作--符号执行在操作系统和用户程序中的应用" data-anchor-alias="para-32-前人工作-3" style="position: relative; top: 0px;"></span><strong>符号执行在操作系统和用户程序中的应用</strong>: <code>Symbex</code> 已被证明在查找操作系统 ([6]) 和用户程序 ([3, 19]) 中的问题方面非常有效。例如，<code>Klee</code> ([3]) 是一个著名的 <code>Symbex</code> 工具，能够为复杂系统程序自动生成高覆盖率的测试。<code>S2E</code> ([6]) 则是一个用于在活体环境中进行多路径分析的平台。这些工具证明了 <code>Symbex</code> 在确保软件正确性方面的强大能力。</li>
<li id="para-32-前人工作-4" data-para-index="4" data-para-heading="32-前人工作" data-para-heading-title="3.2. 前人工作" data-para-sub-title="eBPF 的应用" data-para-sub-slug="ebpf-的应用" data-para-alias="para-32-前人工作--ebpf-的应用"><span id="para-32-前人工作--ebpf-的应用" data-anchor-alias="para-32-前人工作-4" style="position: relative; top: 0px;"></span><strong><code>eBPF</code> 的应用</strong>: <code>eBPF</code> 已被广泛应用于性能监控 ([17, 18])、入侵检测 ([2, 21]) 以及各种特定应用逻辑 ([15, 22, 35, 37])。例如，<code>BMC</code> ([15]) 使用 <code>eBPF</code> 加速 <code>Memcached</code>，<code>XRP</code> ([37]) 使用 <code>eBPF</code> 实现内核存储功能。这些应用展示了 <code>eBPF</code> 的潜力和灵活性。</li>
</ul>
<h2 id="33-技术演进" tabindex="-1">3.3. 技术演进</h2>
<p id="para-33-技术演进-1" data-para-index="1" data-para-heading="33-技术演进" data-para-heading-title="3.3. 技术演进"><code>KGeNT</code> 的工作建立在多个技术发展趋势的交叉点上：</p>
<ol>
<li id="para-33-技术演进-2" data-para-index="2" data-para-heading="33-技术演进" data-para-heading-title="3.3. 技术演进">
<p><strong><code>eBPF</code> 的兴起</strong>: <code>eBPF</code> 从最初的网络追踪工具发展成为通用的内核扩展机制，极大地增强了操作系统的可观测性、安全性和可编程性。但其高学习曲线和编程限制一直是其广泛应用的主要障碍。</p>
</li>
<li id="para-33-技术演进-3" data-para-index="3" data-para-heading="33-技术演进" data-para-heading-title="3.3. 技术演进">
<p><strong><code>LLM</code> 的能力飞跃</strong>: <code>LLM</code> 近年来在自然语言处理和代码理解/生成方面取得了突破性进展，使得从自然语言提示生成代码成为可能。</p>
</li>
<li id="para-33-技术演进-4" data-para-index="4" data-para-heading="33-技术演进" data-para-heading-title="3.3. 技术演进">
<p><strong>形式化验证工具的成熟</strong>: 符号执行、模型检测等形式化验证技术日益成熟，能够对复杂程序进行严格的正确性证明，从而提高了软件的质量和安全性。</p>
<p><code>KGeNT</code> 处于将 <code>LLM</code> 的“创造力”与形式化验证的“严谨性”结合以解决实际软件工程问题的技术脉络中。它试图弥合 <code>eBPF</code> 的强大功能与其开发难度之间的鸿沟，使非专家也能安全有效地利用 <code>eBPF</code>。</p>
</li>
</ol>
<h2 id="34-差异化分析" tabindex="-1">3.4. 差异化分析</h2>
<p id="para-34-差异化分析-1" data-para-index="1" data-para-heading="34-差异化分析" data-para-heading-title="3.4. 差异化分析"><code>KGeNT</code> 与现有工作的核心区别和创新点在于其<strong>独特的组合方式</strong>和<strong>反馈驱动的验证策略</strong>：</p>
<ul>
<li id="para-34-差异化分析-2" data-para-index="2" data-para-heading="34-差异化分析" data-para-heading-title="3.4. 差异化分析" data-para-sub-title="整合 LLM 程序合成与程序理解" data-para-sub-slug="整合-llm-程序合成与程序理解" data-para-alias="para-34-差异化分析--整合-llm-程序合成与程序理解"><span id="para-34-差异化分析--整合-llm-程序合成与程序理解" data-anchor-alias="para-34-差异化分析-2" style="position: relative; top: 0px;"></span><strong>整合 LLM 程序合成与程序理解</strong>: 虽然 <code>LLM</code> 单独在程序合成 ([5]) 和程序理解 ([1, 12]) 方面都取得了成功，但 <code>KGeNT</code> 首次将这两种能力与形式化验证技术——<strong>符号执行</strong>——结合起来。<code>KGeNT</code> 的<strong>理解引擎 (Comprehension Engine)</strong> 利用 <code>LLM</code> 为合成的 <code>eBPF</code> 程序自动生成 <strong>Hoare 逻辑 (Hoare Logic)</strong> 契约（前置和后置条件），这与传统 <code>LLM</code> 仅生成自然语言描述的程序理解方式不同。</li>
<li id="para-34-差异化分析-3" data-para-index="3" data-para-heading="34-差异化分析" data-para-heading-title="3.4. 差异化分析" data-para-sub-title="符号执行的创新结构" data-para-sub-slug="符号执行的创新结构" data-para-alias="para-34-差异化分析--符号执行的创新结构"><span id="para-34-差异化分析--符号执行的创新结构" data-anchor-alias="para-34-差异化分析-3" style="position: relative; top: 0px;"></span><strong>符号执行的创新结构</strong>: <code>KGeNT</code> 以一种新颖的结构使用符号执行，它不仅验证 <code>LLM</code> 合成的代码，还<strong>结合了 <code>LLM</code> 理解的 Hoare 逻辑条件</strong>。这意味着验证过程不仅检查代码是否符合安全规范，还检查它是否满足 <code>LLM</code> 从用户意图和内核语义中“理解”到的功能规范。这比简单地将 <code>LLM</code> 生成的代码直接传递给验证器更为深入和可靠。</li>
<li id="para-34-差异化分析-4" data-para-index="4" data-para-heading="34-差异化分析" data-para-heading-title="3.4. 差异化分析" data-para-sub-title="双重反馈循环" data-para-sub-slug="双重反馈循环" data-para-alias="para-34-差异化分析--双重反馈循环"><span id="para-34-差异化分析--双重反馈循环" data-anchor-alias="para-34-差异化分析-4" style="position: relative; top: 0px;"></span><strong>双重反馈循环</strong>: <code>KGeNT</code> 包含两个反馈循环：一个来自<strong>符号验证器 (Symbolic Verifier)</strong>（语义正确性），另一个来自<strong><code>eBPF</code> 验证器 (eBPF Verifier)</strong>（安全性和运行限制）。这些反馈信息会被传递回 <strong>Prompter</strong>，指导 <code>LLM</code> 在后续迭代中修正生成，从而实现程序的迭代优化和更高的正确率。这种反馈机制是其实现高准确率和低假阳性率的关键。</li>
<li id="para-34-差异化分析-5" data-para-index="5" data-para-heading="34-差异化分析" data-para-heading-title="3.4. 差异化分析" data-para-sub-title="针对 eBPF 的特化" data-para-sub-slug="针对-ebpf-的特化" data-para-alias="para-34-差异化分析--针对-ebpf-的特化"><span id="para-34-差异化分析--针对-ebpf-的特化" data-anchor-alias="para-34-差异化分析-5" style="position: relative; top: 0px;"></span><strong>针对 <code>eBPF</code> 的特化</strong>: <code>KGeNT</code> 专门针对 <code>eBPF</code> 这一特定且复杂的内核扩展领域进行了优化，包括创建专门的 <code>eBPF</code> 数据集 (<code>EBPFNLDATAsET</code> 和 <code>KERNELCoMPDATAsET</code>)。这使得它能够有效应对 <code>eBPF</code> 编程中特有的挑战，如内核内部知识需求和 <code>eBPF</code> 验证器的限制。</li>
</ul>
<h1 id="4-方法论" tabindex="-1">4. 方法论</h1>
<h2 id="41-方法原理" tabindex="-1">4.1. 方法原理</h2>
<p id="para-41-方法原理-1" data-para-index="1" data-para-heading="41-方法原理" data-para-heading-title="4.1. 方法原理"><code>KGeNT</code> 的核心思想是<strong>将自然语言描述的内核扩展需求转化为可执行且经过验证的 <code>eBPF</code> 程序</strong>。其背后直觉是，大语言模型在代码生成和理解方面表现出色，但其输出的<strong>正确性 (correctness)</strong> 和<strong>安全性 (safety)</strong> 仍需严格验证，尤其是在内核这种敏感环境中。<code>KGeNT</code> 通过将 <code>LLM</code> 的生成能力与<strong>形式化验证 (formal verification)</strong> 的严谨性（通过<strong>符号执行 (symbolic execution)</strong> 实现）相结合，构建了一个强大的反馈驱动系统。它利用 <code>LLM</code> 进行初步的程序合成和内核函数行为理解，然后使用符号执行来严格检查 <code>LLM</code> 生成代码的<strong>语义等价性 (semantic equivalence)</strong> 和<strong>安全性 (safety)</strong>。如果验证失败，错误信息将反馈给 <code>LLM</code>，指导其迭代修正，直到生成符合要求且安全可靠的 <code>eBPF</code> 程序。</p>
<h2 id="42-核心方法详解-逐层深入" tabindex="-1">4.2. 核心方法详解 (逐层深入)</h2>
<p id="para-42-核心方法详解-逐层深入-1" data-para-index="1" data-para-heading="42-核心方法详解-逐层深入" data-para-heading-title="4.2. 核心方法详解 (逐层深入)"><code>KGeNT</code> 系统的设计和实现包含了四个主要组件：<strong>Prompter (提示器)</strong>、<strong>Synthesis Engine (合成引擎)</strong>、<strong>Comprehension Engine (理解引擎)</strong> 和 <strong>Symbolic Verifier (符号验证器)</strong>。此外，系统还利用了<strong>现有的 <code>eBPF</code> 验证器 (eBPF verifier)</strong>。整个系统采用<strong>上下文学习 (in-context learning)</strong> 的方式增强现有 <code>LLM</code>，无需重新训练模型，使其能够与各种 <code>LLM</code> 兼容。其设计关键在于<strong>提示策略 (prompting strategies)</strong> 和为合成与理解引擎准备的<strong>新数据集 (new datasets)</strong>。<code>KGeNT</code> 采用<strong>反馈驱动 (feedback-driven)</strong> 的方法来迭代合成正确的 <code>eBPF</code> 程序，包含两个反馈循环。</p>
<p id="para-42-核心方法详解-逐层深入-2" data-para-index="2" data-para-heading="42-核心方法详解-逐层深入" data-para-heading-title="4.2. 核心方法详解 (逐层深入)">以下是 <code>KGeNT</code> 的工作流程，如图 1 所示：</p>
<p id="para-42-核心方法详解-逐层深入-3" data-para-index="3" data-para-heading="42-核心方法详解-逐层深入" data-para-heading-title="4.2. 核心方法详解 (逐层深入)"><img src="/files/papers/6971fc30cfa1aabed60f2ed8/images/1.jpg" alt="Figure 1: The Workflow of KGENT" loading="lazy"><br>
<em>该图像是示意图，展示了KGENT的工作流程。图中包含多个模块，包括Prompter、Synthesis Engine、Comprehension Engine、Symbolic Verifier和eBPF Verifier，描述了eBPF候选程序的生成与验证过程。</em></p>
<p id="para-42-核心方法详解-逐层深入-4" data-para-index="4" data-para-heading="42-核心方法详解-逐层深入" data-para-heading-title="4.2. 核心方法详解 (逐层深入)">Figure 1: The Workflow of KGENT</p>
<h3 id="421-工作流程-workflow" tabindex="-1">4.2.1. 工作流程 (Workflow)</h3>
<ol>
<li id="para-421-工作流程-workflow-1" data-para-index="1" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="用户输入提示 (User Prompt)" data-para-sub-slug="用户输入提示-user-prompt" data-para-alias="para-421-工作流程-workflow--用户输入提示-user-prompt"><span id="para-421-工作流程-workflow--用户输入提示-user-prompt" data-anchor-alias="para-421-工作流程-workflow-1" style="position: relative; top: 0px;"></span><strong>用户输入提示 (User Prompt)</strong>: 用户以自然语言（如英语）向 <code>Prompter</code> 发出描述所需 <code>eBPF</code> 程序功能的提示。</li>
<li id="para-421-工作流程-workflow-2" data-para-index="2" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="Prompter 处理 (Prompter Processing)" data-para-sub-slug="prompter-处理-prompter-processing" data-para-alias="para-421-工作流程-workflow--prompter-处理-prompter-processing"><span id="para-421-工作流程-workflow--prompter-处理-prompter-processing" data-anchor-alias="para-421-工作流程-workflow-2" style="position: relative; top: 0px;"></span><strong>Prompter 处理 (Prompter Processing)</strong>: <code>Prompter</code> 接收用户提示，并对其进行特殊格式化。它会添加<strong>样板文本 (boilerplate text)</strong> 指示 <code>KGeNT</code> 生成适用于 <code>bpftrace</code> 框架的 <code>eBPF</code> 程序。此外，<code>Prompter</code> 会将之前迭代中从<strong>所有反馈循环 (all feedback loops)</strong> 接收到的所有错误消息附加到当前提示中。</li>
<li id="para-421-工作流程-workflow-3" data-para-index="3" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="合成引擎 (Synthesis Engine)" data-para-sub-slug="合成引擎-synthesis-engine" data-para-alias="para-421-工作流程-workflow--合成引擎-synthesis-engine"><span id="para-421-工作流程-workflow--合成引擎-synthesis-engine" data-anchor-alias="para-421-工作流程-workflow-3" style="position: relative; top: 0px;"></span><strong>合成引擎 (Synthesis Engine)</strong>: <code>Prompter</code> 将处理后的提示转发给 <code>KGeNT</code> 的 <code>Synthesis Engine</code>。<code>Synthesis Engine</code> 调用一个 <code>LLM</code>，根据用户输入和附加的反馈信息来<strong>合成 (synthesize)</strong> 一个候选 <code>eBPF</code> 程序。为了实现<strong>上下文学习 (in-context learning)</strong>，<code>Synthesis Engine</code> 会从其 <code>VectorDB</code> 中检索与当前用户提示最相似的“提示-<code>eBPF</code> 程序对”作为<strong>少样本示例 (few-shot examples)</strong>，并将其包含在对 <code>LLM</code> 的查询中。</li>
<li id="para-421-工作流程-workflow-4" data-para-index="4" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="理解引擎 (Comprehension Engine)" data-para-sub-slug="理解引擎-comprehension-engine" data-para-alias="para-421-工作流程-workflow--理解引擎-comprehension-engine"><span id="para-421-工作流程-workflow--理解引擎-comprehension-engine" data-anchor-alias="para-421-工作流程-workflow-4" style="position: relative; top: 0px;"></span><strong>理解引擎 (Comprehension Engine)</strong>: <code>KGeNT</code> 将这个候选 <code>eBPF</code> 程序传递给 <code>Comprehension Engine</code>。<code>Comprehension Engine</code> 同样调用一个 <code>LLM</code>，为候选 <code>eBPF</code> 程序中引用的每个<strong>内核函数 (Kernel functions)</strong> <strong>注解 (annotate)</strong> <strong>Hoare 逻辑 (Hoare-logic)</strong> 的<strong>前置条件 (pre-conditions)</strong> 和<strong>后置条件 (post-conditions)</strong>。这个过程会利用**<code>KERNELCoMPDATAsET</code> (Kernel Composition Data Set)** 中的条件信息、原始开发者提示和 <code>eBPF</code> 函数本身。</li>
<li id="para-421-工作流程-workflow-5" data-para-index="5" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="符号验证器 (Symbolic Verifier)" data-para-sub-slug="符号验证器-symbolic-verifier" data-para-alias="para-421-工作流程-workflow--符号验证器-symbolic-verifier"><span id="para-421-工作流程-workflow--符号验证器-symbolic-verifier" data-anchor-alias="para-421-工作流程-workflow-5" style="position: relative; top: 0px;"></span><strong>符号验证器 (Symbolic Verifier)</strong>: <code>KGeNT</code> 将这个带有 <code>Hoare</code> 逻辑注解的 <code>eBPF</code> 候选程序传递给其 <code>Symbolic Verifier</code>。<code>Symbolic Verifier</code> 使用<strong>符号执行 (symbolic execution)</strong> 来验证合成的 <code>eBPF</code> 程序是否满足这些 <code>Hoare</code> 逻辑属性。
<ul>
<li id="para-421-工作流程-workflow-6" data-para-index="6" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="失败/超时反馈" data-para-sub-slug="失败超时反馈" data-para-alias="para-421-工作流程-workflow--失败超时反馈"><span id="para-421-工作流程-workflow--失败超时反馈" data-anchor-alias="para-421-工作流程-workflow-6" style="position: relative; top: 0px;"></span><strong>失败/超时反馈</strong>: 如果 <code>Symbolic Verifier</code> 发现程序不满足断言（即 <code>Hoare</code> 逻辑条件不成立）或验证超时，它会将错误消息传递回 <code>Prompter</code>，开始新一轮的 <code>KGeNT</code> 迭代。</li>
<li id="para-421-工作流程-workflow-7" data-para-index="7" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="成功" data-para-sub-slug="成功" data-para-alias="para-421-工作流程-workflow--成功"><span id="para-421-工作流程-workflow--成功" data-anchor-alias="para-421-工作流程-workflow-7" style="position: relative; top: 0px;"></span><strong>成功</strong>: 如果 <code>Symbolic Verifier</code> 成功，它会移除程序中的断言/假设语句，并将 <code>eBPF</code> 程序传递给<strong><code>eBPF</code> 验证器 (eBPF verifier)</strong>。</li>
</ul>
</li>
<li id="para-421-工作流程-workflow-8" data-para-index="8" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="eBPF 验证器 (eBPF Verifier)" data-para-sub-slug="ebpf-验证器-ebpf-verifier" data-para-alias="para-421-工作流程-workflow--ebpf-验证器-ebpf-verifier"><span id="para-421-工作流程-workflow--ebpf-验证器-ebpf-verifier" data-anchor-alias="para-421-工作流程-workflow-8" style="position: relative; top: 0px;"></span><strong><code>eBPF</code> 验证器 (eBPF Verifier)</strong>: <code>KGeNT</code> 使用操作系统中现有的 <code>eBPF</code> 验证器来验证程序的<strong>安全属性 (safety properties)</strong>，例如检查是否存在无界循环或任意内存访问。
<ul>
<li id="para-421-工作流程-workflow-9" data-para-index="9" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="失败反馈" data-para-sub-slug="失败反馈" data-para-alias="para-421-工作流程-workflow--失败反馈"><span id="para-421-工作流程-workflow--失败反馈" data-anchor-alias="para-421-工作流程-workflow-9" style="position: relative; top: 0px;"></span><strong>失败反馈</strong>: 如果 <code>eBPF</code> 验证器认为程序不安全，它会将错误消息传递回 <code>Prompter</code>，开始新一轮的 <code>KGeNT</code> 迭代。</li>
<li id="para-421-工作流程-workflow-10" data-para-index="10" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="成功" data-para-sub-slug="成功" data-para-alias="para-421-工作流程-workflow--成功"><strong>成功</strong>: 如果 <code>eBPF</code> 验证器成功，它将 <code>eBPF</code> 候选程序作为最终合成的 <code>eBPF</code> 程序传递给用户。</li>
</ul>
</li>
<li id="para-421-工作流程-workflow-11" data-para-index="11" data-para-heading="421-工作流程-workflow" data-para-heading-title="4.2.1. 工作流程 (Workflow)" data-para-sub-title="迭代与用户交互" data-para-sub-slug="迭代与用户交互" data-para-alias="para-421-工作流程-workflow--迭代与用户交互"><span id="para-421-工作流程-workflow--迭代与用户交互" data-anchor-alias="para-421-工作流程-workflow-11" style="position: relative; top: 0px;"></span><strong>迭代与用户交互</strong>: 如果 <code>KGeNT</code> 在经过预设的迭代次数（默认为 3 次）后仍未能合成出经过验证的 <code>eBPF</code> 程序，系统将重新提示用户，建议用户提供额外的语义提示（例如，变量的预期大小），这通常能解决合成问题。</li>
</ol>
<h3 id="422-prompter" tabindex="-1">4.2.2. Prompter</h3>
<p id="para-422-prompter-1" data-para-index="1" data-para-heading="422-prompter" data-para-heading-title="4.2.2. Prompter"><code>Prompter</code> 的主要职责是准备 <code>LLM</code> 的输入。它不仅接收用户的原始自然语言提示，还执行以下功能：</p>
<ul>
<li id="para-422-prompter-2" data-para-index="2" data-para-heading="422-prompter" data-para-heading-title="4.2.2. Prompter" data-para-sub-title="格式化" data-para-sub-slug="格式化" data-para-alias="para-422-prompter--格式化"><span id="para-422-prompter--格式化" data-anchor-alias="para-422-prompter-2" style="position: relative; top: 0px;"></span><strong>格式化</strong>: 添加标准<strong>样板文本 (boilerplate text)</strong>，例如指示 <code>LLM</code> 生成 <code>bpftrace</code> 框架下的 <code>eBPF</code> 程序。这有助于规范 <code>LLM</code> 的输出格式。</li>
<li id="para-422-prompter-3" data-para-index="3" data-para-heading="422-prompter" data-para-heading-title="4.2.2. Prompter" data-para-sub-title="错误信息聚合" data-para-sub-slug="错误信息聚合" data-para-alias="para-422-prompter--错误信息聚合"><span id="para-422-prompter--错误信息聚合" data-anchor-alias="para-422-prompter-3" style="position: relative; top: 0px;"></span><strong>错误信息聚合</strong>: <code>Prompter</code> 会收集所有<strong>反馈循环 (feedback loops)</strong>（来自 <code>Symbolic Verifier</code> 和 <code>eBPF</code> Verifier）在当前合成任务中产生的错误消息。在每次迭代中，它会将这些历史错误消息附加到新的提示中，传递给 <code>Synthesis Engine</code>。这种机制允许 <code>LLM</code> 从之前的失败中“学习”，并尝试生成更正后的程序。例如，如果第一次迭代因 <code>Symbolic Verifier</code> 失败，第二次迭代因 <code>eBPF</code> Verifier 失败，<code>Prompter</code> 会将这两个错误消息都附加到第三次迭代的提示中。</li>
</ul>
<h3 id="423-synthesis-engine-合成引擎" tabindex="-1">4.2.3. Synthesis Engine (合成引擎)</h3>
<p id="para-423-synthesis-engine-合成引擎-1" data-para-index="1" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)"><code>Synthesis Engine</code> 负责根据自然语言提示生成候选 <code>eBPF</code> 程序。</p>
<ul>
<li id="para-423-synthesis-engine-合成引擎-2" data-para-index="2" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)" data-para-sub-title="LLM 交互" data-para-sub-slug="llm-交互" data-para-alias="para-423-synthesis-engine-合成引擎--llm-交互"><span id="para-423-synthesis-engine-合成引擎--llm-交互" data-anchor-alias="para-423-synthesis-engine-合成引擎-2" style="position: relative; top: 0px;"></span><strong><code>LLM</code> 交互</strong>: 它使用 <code>LangChain</code> ([20]) 作为与任意 <code>LLM</code> 交互的机制。这种设计使得 <code>KGeNT</code> 能够支持不同的 <code>LLM</code>，以平衡隐私、成本和性能。</li>
<li id="para-423-synthesis-engine-合成引擎-3" data-para-index="3" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)" data-para-sub-title="上下文学习 (In-context Learning)" data-para-sub-slug="上下文学习-in-context-learning" data-para-alias="para-423-synthesis-engine-合成引擎--上下文学习-in-context-learning"><span id="para-423-synthesis-engine-合成引擎--上下文学习-in-context-learning" data-anchor-alias="para-423-synthesis-engine-合成引擎-3" style="position: relative; top: 0px;"></span><strong>上下文学习 (In-context Learning)</strong>: <code>Synthesis Engine</code> 利用一个 <strong>VectorDB (向量数据库)</strong>（例如 <code>Milvus</code> ([31])）来实现上下文学习。
<ul>
<li id="para-423-synthesis-engine-合成引擎-4" data-para-index="4" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)" data-para-sub-title="EBPFNLDATAsET" data-para-sub-slug="ebpfnldataset" data-para-alias="para-423-synthesis-engine-合成引擎--ebpfnldataset"><span id="para-423-synthesis-engine-合成引擎--ebpfnldataset" data-anchor-alias="para-423-synthesis-engine-合成引擎-4" style="position: relative; top: 0px;"></span><strong><code>EBPFNLDATAsET</code></strong>: <code>VectorDB</code> 中存储了来自 <code>EBPFNLDATAsET</code> 数据集的“提示-<code>eBPF</code> 程序对”。</li>
<li id="para-423-synthesis-engine-合成引擎-5" data-para-index="5" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)" data-para-sub-title="相似性检索" data-para-sub-slug="相似性检索" data-para-alias="para-423-synthesis-engine-合成引擎--相似性检索"><span id="para-423-synthesis-engine-合成引擎--相似性检索" data-anchor-alias="para-423-synthesis-engine-合成引擎-5" style="position: relative; top: 0px;"></span><strong>相似性检索</strong>: 在每次查询时，引擎会使用 <code>VectorDB</code> 识别与用户提示最相似的“提示-<code>eBPF</code> 程序对”。</li>
<li id="para-423-synthesis-engine-合成引擎-6" data-para-index="6" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)" data-para-sub-title="少样本学习" data-para-sub-slug="少样本学习" data-para-alias="para-423-synthesis-engine-合成引擎--少样本学习"><span id="para-423-synthesis-engine-合成引擎--少样本学习" data-anchor-alias="para-423-synthesis-engine-合成引擎-6" style="position: relative; top: 0px;"></span><strong>少样本学习</strong>: 这些相似的对作为<strong>正确输入-输出示例 (examples of correct input-output pairs)</strong> 包含在对 <code>LLM</code> 的查询中，从而实现了<strong>少样本学习 (few-shot learning)</strong> ([32])。</li>
</ul>
</li>
<li id="para-423-synthesis-engine-合成引擎-7" data-para-index="7" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)" data-para-sub-title="迭代学习" data-para-sub-slug="迭代学习" data-para-alias="para-423-synthesis-engine-合成引擎--迭代学习"><span id="para-423-synthesis-engine-合成引擎--迭代学习" data-anchor-alias="para-423-synthesis-engine-合成引擎-7" style="position: relative; top: 0px;"></span><strong>迭代学习</strong>: <code>KGeNT</code> 每次成功或失败的 <code>eBPF</code> 合成后，都会更新其 <code>VectorDB</code>，从而允许系统从经验中学习。</li>
<li id="para-423-synthesis-engine-合成引擎-8" data-para-index="8" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)" data-para-sub-title="EBPFNLDATAsET 数据集" data-para-sub-slug="ebpfnldataset-数据集" data-para-alias="para-423-synthesis-engine-合成引擎--ebpfnldataset-数据集"><span id="para-423-synthesis-engine-合成引擎--ebpfnldataset-数据集" data-anchor-alias="para-423-synthesis-engine-合成引擎-8" style="position: relative; top: 0px;"></span><strong><code>EBPFNLDATAsET</code> 数据集</strong>: 这是一个新颖的数据集，包含 145 对自然语言提示和对应的 <code>eBPF</code> 程序。
<ul>
<li id="para-423-synthesis-engine-合成引擎-9" data-para-index="9" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)">其中 79 对是 <code>bpftrace</code> 程序，66 对是 <code>libbpf</code> 程序。</li>
<li id="para-423-synthesis-engine-合成引擎-10" data-para-index="10" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)">数据来源:
<ul>
<li id="para-423-synthesis-engine-合成引擎-11" data-para-index="11" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)">65 对 (39 <code>bpftrace</code>, 26 <code>libbpf</code>) 来自一个流行的 <code>eBPF</code> 开发者博客 ([16])。</li>
<li id="para-423-synthesis-engine-合成引擎-12" data-para-index="12" data-para-heading="423-synthesis-engine-合成引擎" data-para-heading-title="4.2.3. Synthesis Engine (合成引擎)">80 对 (40 <code>bpftrace</code>, 40 <code>libbpf</code>) 是根据 <code>bcc</code> ([27])、<code>bpftrace</code> ([30])、<code>ebpf-exporter</code> ([8]) 或 <code>bpftime</code> ([36]) 等知名开源 <code>eBPF</code> 项目仓库中的示例手工编写的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="424-comprehension-engine-理解引擎" tabindex="-1">4.2.4. Comprehension Engine (理解引擎)</h3>
<p id="para-424-comprehension-engine-理解引擎-1" data-para-index="1" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)"><code>Comprehension Engine</code> 的任务是使用 <code>LLM</code> 为候选 <code>eBPF</code> 程序注解 <strong>Hoare 逻辑 (Hoare-logic)</strong> 的前置和后置条件。</p>
<ul>
<li id="para-424-comprehension-engine-理解引擎-2" data-para-index="2" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)" data-para-sub-title="LLM 提示" data-para-sub-slug="llm-提示" data-para-alias="para-424-comprehension-engine-理解引擎--llm-提示"><span id="para-424-comprehension-engine-理解引擎--llm-提示" data-anchor-alias="para-424-comprehension-engine-理解引擎-2" style="position: relative; top: 0px;"></span><strong><code>LLM</code> 提示</strong>: 它使用一个包含 <code>eBPF</code> 函数、开发者提示以及来自 <code>KERNELCoMPDATAsET</code> 的条件的 <code>LLM</code> 提示。这种方法允许引擎利用开发者的原始意图，平滑 <code>KERNELCoMPDATAsET</code> 中可能存在的自动化生成的不准确性，并通过更新内部的 <code>VectorDB</code> 从错误和成功中学习。</li>
<li id="para-424-comprehension-engine-理解引擎-3" data-para-index="3" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)" data-para-sub-title="KERNELCoMPDATAsET 数据集" data-para-sub-slug="kernelcompdataset-数据集" data-para-alias="para-424-comprehension-engine-理解引擎--kernelcompdataset-数据集"><span id="para-424-comprehension-engine-理解引擎--kernelcompdataset-数据集" data-anchor-alias="para-424-comprehension-engine-理解引擎-3" style="position: relative; top: 0px;"></span><strong><code>KERNELCoMPDATAsET</code> 数据集</strong>: 这个数据集包含了内核函数的 <code>Hoare</code> 逻辑契约。由于手动创建所有可 <code>eBPF</code> 检测的内核函数的契约是不可行的（函数数量庞大且随内核版本变化），作者采用了<strong>自动化方法</strong>：
<ol>
<li id="para-424-comprehension-engine-理解引擎-4" data-para-index="4" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)">
<p>使用<strong>正则表达式 (regular expression)</strong> 识别内核中所有带有符号的函数。</p>
</li>
<li id="para-424-comprehension-engine-理解引擎-5" data-para-index="5" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)">
<p>通过正则表达式查找函数紧前的注释来<strong>近似函数的语义 (approximate the function's semantics)</strong>。</p>
</li>
<li id="para-424-comprehension-engine-理解引擎-6" data-para-index="6" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)">
<p>将函数原型、源代码和近似语义输入到一个 <code>LLM</code> 中，并提示 <code>LLM</code> 为每个 <code>eBPF</code> 辅助函数生成 <strong>Z3 兼容 (Z3 compatible)</strong> 的条件。</p>
</li>
<li id="para-424-comprehension-engine-理解引擎-7" data-para-index="7" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)">
<p>这些近似语义、原型和 <code>LLM</code> 输出以 JSON 格式存储在 <code>KERNELCoMPDATAsET</code> 中。开发者可以修复自动化方法中的不准确之处，尽管作者在 <code>KGeNT</code> 中尚未需要这样做。</p>
<p>以下是原文 Figure 3，展示了 <code>KERNELCoMPDATAsET</code> 中 <code>kretprobe:tcp_connect_init</code> 的匹配元素 JSON 示例：</p>
<p><img src="/files/papers/6971fc30cfa1aabed60f2ed8/images/3.jpg" alt="Figure 3: JSON for the matching element in KeRNeLCoMpDAtaseT for the kernel probe" loading="lazy">
<em>该图像是示意图，展示了与 'kretprobe:tcp_connect_init' 相关的 JSON 结构，其中包含 'pre' 和 'sk' 的值设定。 'sk' 的条件为 '!=null'。</em></p>
</li>
</ol>
</li>
</ul>
<p id="para-424-comprehension-engine-理解引擎-8" data-para-index="8" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)">Figure 3: JSON for the matching element in KeRNeLCoMPDAtaseT for the kernel probe</p>
<p id="para-424-comprehension-engine-理解引擎-9" data-para-index="9" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)">以下是原文 Figure 4，展示了由 <code>Comprehension Engine</code> 为验证而生成的带注解的候选 <code>eBPF</code> 程序：</p>
<p id="para-424-comprehension-engine-理解引擎-10" data-para-index="10" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)"><img src="/files/papers/6971fc30cfa1aabed60f2ed8/images/4.jpg" alt="Figure 4: Annotated candidate eBPF program produced by the Comprehension Engine for verification. The original synthesized eBPF program is shown in gray. Pre-conditions inferred from KeRNeLCoMpDaTAseT are shown in pink. Preconditions inferred from the user prompt are shown in yellow. Finally, post-conditions inferred from the user's prompt are shown in blue." loading="lazy"><br>
<em>该图像是一个示意图，展示了由理解引擎生成的候选 eBPF 程序，通过不同的颜色标注出原始程序、预条件和后条件。原始合成的 eBPF 程序用灰色显示，已从 KeRNeLCoMpDaTAseT 推断出的预条件用粉色显示，基于用户提示推断的预条件用黄色显示，用户提示推断的后条件用蓝色显示。</em></p>
<p id="para-424-comprehension-engine-理解引擎-11" data-para-index="11" data-para-heading="424-comprehension-engine-理解引擎" data-para-heading-title="4.2.4. Comprehension Engine (理解引擎)">Figure 4: Annotated candidate eBPF program produced by the Comprehension Engine for verification. The original synthesized eBPF program is shown in gray. Pre-conditions inferred from KeRNeLCoMPDaTAseT are shown in pink. Preconditions inferred from the user prompt are shown in yellow. Finally, post-conditions inferred from the user's prompt are shown in blue.</p>
<h3 id="425-symbolic-verifier-符号验证器" tabindex="-1">4.2.5. Symbolic Verifier (符号验证器)</h3>
<p id="para-425-symbolic-verifier-符号验证器-1" data-para-index="1" data-para-heading="425-symbolic-verifier-符号验证器" data-para-heading-title="4.2.5. Symbolic Verifier (符号验证器)"><code>Symbolic Verifier</code> 使用<strong>符号执行 (symbolic execution)</strong> 来验证 <code>Comprehension Engine</code> 生成的带注解 <code>eBPF</code> 候选程序。</p>
<ul>
<li id="para-425-symbolic-verifier-符号验证器-2" data-para-index="2" data-para-heading="425-symbolic-verifier-符号验证器" data-para-heading-title="4.2.5. Symbolic Verifier (符号验证器)" data-para-sub-title="验证过程" data-para-sub-slug="验证过程" data-para-alias="para-425-symbolic-verifier-符号验证器--验证过程"><span id="para-425-symbolic-verifier-符号验证器--验证过程" data-anchor-alias="para-425-symbolic-verifier-符号验证器-2" style="position: relative; top: 0px;"></span><strong>验证过程</strong>: 它检查程序是否满足所有 <code>assert</code> 语句（即 <code>Hoare</code> 逻辑的前置和后置条件）。</li>
<li id="para-425-symbolic-verifier-符号验证器-3" data-para-index="3" data-para-heading="425-symbolic-verifier-符号验证器" data-para-heading-title="4.2.5. Symbolic Verifier (符号验证器)" data-para-sub-title="成功处理" data-para-sub-slug="成功处理" data-para-alias="para-425-symbolic-verifier-符号验证器--成功处理"><span id="para-425-symbolic-verifier-符号验证器--成功处理" data-anchor-alias="para-425-symbolic-verifier-符号验证器-3" style="position: relative; top: 0px;"></span><strong>成功处理</strong>: 如果验证器确定程序满足所有断言，它会移除这些 <code>assert/assume</code> 语句，并将候选 <code>eBPF</code> 程序传递给 <strong><code>eBPF</code> 验证器 (eBPF verifier)</strong>。</li>
<li id="para-425-symbolic-verifier-符号验证器-4" data-para-index="4" data-para-heading="425-symbolic-verifier-符号验证器" data-para-heading-title="4.2.5. Symbolic Verifier (符号验证器)" data-para-sub-title="失败/超时处理" data-para-sub-slug="失败超时处理" data-para-alias="para-425-symbolic-verifier-符号验证器--失败超时处理"><span id="para-425-symbolic-verifier-符号验证器--失败超时处理" data-anchor-alias="para-425-symbolic-verifier-符号验证器-4" style="position: relative; top: 0px;"></span><strong>失败/超时处理</strong>: 如果 <code>Symbolic Verifier</code> 发现某个断言不成立或验证超时，它会将错误消息传递回 <code>Prompter</code>，触发新的迭代。</li>
</ul>
<h3 id="426-ebpf-verifier-ebpf-验证器" tabindex="-1">4.2.6. eBPF Verifier (eBPF 验证器)</h3>
<p id="para-426-ebpf-verifier-ebpf-验证器-1" data-para-index="1" data-para-heading="426-ebpf-verifier-ebpf-验证器" data-para-heading-title="4.2.6. eBPF Verifier (eBPF 验证器)"><code>KGeNT</code> 利用操作系统中现有的 <code>eBPF</code> 验证器。</p>
<ul>
<li id="para-426-ebpf-verifier-ebpf-验证器-2" data-para-index="2" data-para-heading="426-ebpf-verifier-ebpf-验证器" data-para-heading-title="4.2.6. eBPF Verifier (eBPF 验证器)" data-para-sub-title="安全验证" data-para-sub-slug="安全验证" data-para-alias="para-426-ebpf-verifier-ebpf-验证器--安全验证"><span id="para-426-ebpf-verifier-ebpf-验证器--安全验证" data-anchor-alias="para-426-ebpf-verifier-ebpf-验证器-2" style="position: relative; top: 0px;"></span><strong>安全验证</strong>: <code>eBPF</code> 验证器确保 <code>Symbolic Verifier</code> 提供的 <code>eBPF</code> 候选程序符合基本的<strong>安全标准 (basic security criteria)</strong>，例如不包含无界循环或任意内存访问。</li>
<li id="para-426-ebpf-verifier-ebpf-验证器-3" data-para-index="3" data-para-heading="426-ebpf-verifier-ebpf-验证器" data-para-heading-title="4.2.6. eBPF Verifier (eBPF 验证器)" data-para-sub-title="失败处理" data-para-sub-slug="失败处理" data-para-alias="para-426-ebpf-verifier-ebpf-验证器--失败处理"><span id="para-426-ebpf-verifier-ebpf-验证器--失败处理" data-anchor-alias="para-426-ebpf-verifier-ebpf-验证器-3" style="position: relative; top: 0px;"></span><strong>失败处理</strong>: 如果 <code>eBPF</code> 验证器无法保证候选程序是安全的，它会将错误消息传递回 <code>Prompter</code>，触发新的迭代。</li>
<li id="para-426-ebpf-verifier-ebpf-验证器-4" data-para-index="4" data-para-heading="426-ebpf-verifier-ebpf-验证器" data-para-heading-title="4.2.6. eBPF Verifier (eBPF 验证器)" data-para-sub-title="成功处理" data-para-sub-slug="成功处理" data-para-alias="para-426-ebpf-verifier-ebpf-验证器--成功处理"><span id="para-426-ebpf-verifier-ebpf-验证器--成功处理" data-anchor-alias="para-426-ebpf-verifier-ebpf-验证器-4" style="position: relative; top: 0px;"></span><strong>成功处理</strong>: 如果 <code>eBPF</code> 验证器成功，它将 <code>eBPF</code> 候选程序作为最终合成的 <code>eBPF</code> 程序提供给用户。</li>
</ul>
<h3 id="427-实现细节-implementation" tabindex="-1">4.2.7. 实现细节 (Implementation)</h3>
<ul>
<li id="para-427-实现细节-implementation-1" data-para-index="1" data-para-heading="427-实现细节-implementation" data-para-heading-title="4.2.7. 实现细节 (Implementation)" data-para-sub-title="代码量" data-para-sub-slug="代码量" data-para-alias="para-427-实现细节-implementation--代码量"><span id="para-427-实现细节-implementation--代码量" data-anchor-alias="para-427-实现细节-implementation-1" style="position: relative; top: 0px;"></span><strong>代码量</strong>: <code>KGeNT</code>、<code>EBPFNLDATAsET</code> 和 <code>KERNELCoMPDATAsET</code> 使用 Python 实现了 4244 行代码。此外，对 <code>bpftrace</code> 编译器增加了 51 行代码，以支持 <code>assume</code> 和 <code>assert</code> 函数。</li>
<li id="para-427-实现细节-implementation-2" data-para-index="2" data-para-heading="427-实现细节-implementation" data-para-heading-title="4.2.7. 实现细节 (Implementation)" data-para-sub-title="核心工具" data-para-sub-slug="核心工具" data-para-alias="para-427-实现细节-implementation--核心工具"><span id="para-427-实现细节-implementation--核心工具" data-anchor-alias="para-427-实现细节-implementation-2" style="position: relative; top: 0px;"></span><strong>核心工具</strong>:
<ul>
<li id="para-427-实现细节-implementation-3" data-para-index="3" data-para-heading="427-实现细节-implementation" data-para-heading-title="4.2.7. 实现细节 (Implementation)"><code>Symbolic Verifier</code>: 使用 <code>SeaHorn</code> ([19])。<code>SeaHorn</code> 能够对 <code>LLVM IR</code> 进行符号执行。</li>
<li id="para-427-实现细节-implementation-4" data-para-index="4" data-para-heading="427-实现细节-implementation" data-para-heading-title="4.2.7. 实现细节 (Implementation)"><code>SMT Solver</code>: 使用 <code>Z3</code> ([10]) 作为其后端 <code>SMT</code> 求解器。</li>
<li id="para-427-实现细节-implementation-5" data-para-index="5" data-para-heading="427-实现细节-implementation" data-para-heading-title="4.2.7. 实现细节 (Implementation)"><code>KGeNT</code> 将 <code>Comprehension Engine</code> 的输出编译为 <code>LLVM IR</code>，然后由 <code>SeaHorn</code> 进行符号执行。</li>
</ul>
</li>
<li id="para-427-实现细节-implementation-6" data-para-index="6" data-para-heading="427-实现细节-implementation" data-para-heading-title="4.2.7. 实现细节 (Implementation)" data-para-sub-title="LLM 支持" data-para-sub-slug="llm-支持" data-para-alias="para-427-实现细节-implementation--llm-支持"><span id="para-427-实现细节-implementation--llm-支持" data-anchor-alias="para-427-实现细节-implementation-6" style="position: relative; top: 0px;"></span><strong><code>LLM</code> 支持</strong>: <code>KGeNT</code> 支持多种 <code>LLM</code>，但默认使用 <code>GPT-4 API</code>。</li>
<li id="para-427-实现细节-implementation-7" data-para-index="7" data-para-heading="427-实现细节-implementation" data-para-heading-title="4.2.7. 实现细节 (Implementation)" data-para-sub-title="平台限制" data-para-sub-slug="平台限制" data-para-alias="para-427-实现细节-implementation--平台限制"><span id="para-427-实现细节-implementation--平台限制" data-anchor-alias="para-427-实现细节-implementation-7" style="position: relative; top: 0px;"></span><strong>平台限制</strong>: 当前 <code>KGeNT</code> 原型仅在 Linux 上运行。</li>
<li id="para-427-实现细节-implementation-8" data-para-index="8" data-para-heading="427-实现细节-implementation" data-para-heading-title="4.2.7. 实现细节 (Implementation)" data-para-sub-title="合成目标" data-para-sub-slug="合成目标" data-para-alias="para-427-实现细节-implementation--合成目标"><span id="para-427-实现细节-implementation--合成目标" data-anchor-alias="para-427-实现细节-implementation-8" style="position: relative; top: 0px;"></span><strong>合成目标</strong>: <code>KGeNT</code> 可以为 <code>libbpf</code> 和 <code>bpftrace</code> 合成 <code>eBPF</code> 程序，但默认选择 <code>bpftrace</code>，因为实验发现 <code>KGeNT</code> 在合成 <code>bpftrace</code> 程序方面更有效。</li>
</ul>
<h1 id="5-实验设置" tabindex="-1">5. 实验设置</h1>
<h2 id="51-数据集" tabindex="-1">5.1. 数据集</h2>
<ul>
<li id="para-51-数据集-1" data-para-index="1" data-para-heading="51-数据集" data-para-heading-title="5.1. 数据集">
<p><strong><code>EBPFNLDATAsET</code></strong>:</p>
<ul>
<li id="para-51-数据集-2" data-para-index="2" data-para-heading="51-数据集" data-para-heading-title="5.1. 数据集">
<p><strong>测试集</strong>: 评估阶段使用了 <code>EBPFNLDATAsET</code> 的一个子集作为测试集，这个子集包含从知名开源 <code>eBPF</code> 项目仓库（如 <code>bcc</code>、<code>bpftrace</code>、<code>ebpf-exporter</code> 或 <code>bpftime</code>）中手动编写的 80 对“提示-<code>eBPF</code> 程序对”（40 <code>bpftrace</code>，40 <code>libbpf</code>）。</p>
</li>
<li id="para-51-数据集-3" data-para-index="3" data-para-heading="51-数据集" data-para-heading-title="5.1. 数据集">
<p><strong>训练集</strong>: <code>KGeNT</code> 的上下文学习（少样本学习）部分使用了 <code>EBPFNLDATAsET</code> 中从流行 <code>eBPF</code> 开发者博客 ([16]) 收集的 65 对“提示-<code>eBPF</code> 程序对”（39 <code>bpftrace</code>，26 <code>libbpf</code>）进行训练。</p>
</li>
<li id="para-51-数据集-4" data-para-index="4" data-para-heading="51-数据集" data-para-heading-title="5.1. 数据集">
<p><strong>特点</strong>: 该数据集旨在覆盖多样化的 <code>eBPF</code> 编程场景和自然语言描述，以全面评估 <code>eBPF</code> 程序合成工具的性能。</p>
</li>
<li id="para-51-数据集-5" data-para-index="5" data-para-heading="51-数据集" data-para-heading-title="5.1. 数据集">
<p><strong>样本示例</strong>: 论文未直接提供数据集中的具体样本示例，但图 2 展示了一个用户提示示例，图 5 展示了一个合成的 <code>eBPF</code> 代码示例。</p>
<p>以下是原文 Figure 2，展示了一个用户提示，指示 <code>KGeNT</code> 打印所有 TCP 连接尝试的基本连接信息：</p>
<p><img src="/files/papers/6971fc30cfa1aabed60f2ed8/images/2.jpg" alt="Figure 2: A prompt passed into KgenT instructing it to print basic connection information for all TCP connect attempts." loading="lazy">
<em>该图像是插图，展示了一个提示，指示 KgenT 编写一个 bpftrace 程序，以跟踪 IPv4 和 IPv6 的 tcp_connect 事件，显示源和目标 IP 地址以及主机字节顺序中的源和目标端口。</em></p>
</li>
</ul>
<p>Figure 2: A prompt passed into KgenT instructing it to print basic connection information for all TCP connect attempts.</p>
<p>以下是原文 Figure 5，展示了针对图 2 提示，<code>Synthesis Engine</code> 在第二次迭代中产生的输出和符号验证失败的错误消息。这里截取了代码部分：</p>
<p><img src="/files/papers/6971fc30cfa1aabed60f2ed8/images/5.jpg" alt="Figure 5: The output of the Synthesis Engine on the second iteration for the prompt of fig. 2 and the error message for the symbolic verification failure of fig. 4" loading="lazy"><br>
<em>该图像是代码示例，展示了TCP连接过程中使用kprobe的一个实现。代码中定义了四个变量：<code>saddr、</code>daddr、<code>sport和</code>dport，通过获取和转换连接的源地址、目标地址及相应的端口号，最后通过printf函数输出连接信息。整体代码为： <code>c kprobe:tcp_connect { <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>n</mi><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">saddr = ntop(2, </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span></span></span></span>sk-&gt;__sk_common.skc_rcv_saddr); <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>n</mi><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">daddr = ntop(2, </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span></span></span></span>sk-&gt;__sk_common.skc_daddr); <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mi>s</mi><mi>w</mi><mi>a</mi><mi>p</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">sport = (bswap(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mopen">(</span></span></span></span>sk-&gt;__sk_common.skc_num)); <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mi>s</mi><mi>w</mi><mi>a</mi><mi>p</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">dport = (bswap(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mopen">(</span></span></span></span>sk-&gt;__sk_common.skc_dport)); printf("TCP connect: %s:%d -&gt; %s:%d\n", `saddr,`sport, `daddr,`port); }</code></em></p>
<p>Figure 5: The output of the Synthesis Engine on the second iteration for the prompt of fig. 2 and the error message for the symbolic verification failure of fig. 4</p>
</li>
<li id="para-51-数据集-6" data-para-index="6" data-para-heading="51-数据集" data-para-heading-title="5.1. 数据集">
<p><strong><code>KERNELCoMPDATAsET</code></strong>:</p>
<ul>
<li id="para-51-数据集-7" data-para-index="7" data-para-heading="51-数据集" data-para-heading-title="5.1. 数据集" data-para-sub-title="来源与特点" data-para-sub-slug="来源与特点" data-para-alias="para-51-数据集--来源与特点"><span id="para-51-数据集--来源与特点" data-anchor-alias="para-51-数据集-7" style="position: relative; top: 0px;"></span><strong>来源与特点</strong>: 这是一个自动生成的内核函数 <code>Hoare</code> 逻辑契约数据集。它通过正则表达式从内核中识别函数，利用函数前的注释近似语义，然后使用 <code>LLM</code> 为 <code>eBPF</code> 辅助函数生成 <code>Z3</code> 兼容的条件。</li>
<li id="para-51-数据集-8" data-para-index="8" data-para-heading="51-数据集" data-para-heading-title="5.1. 数据集" data-para-sub-title="目的" data-para-sub-slug="目的" data-para-alias="para-51-数据集--目的"><span id="para-51-数据集--目的" data-anchor-alias="para-51-数据集-8" style="position: relative; top: 0px;"></span><strong>目的</strong>: 用于 <code>Comprehension Engine</code> 为 <code>eBPF</code> 候选程序注解前置和后置条件。</li>
</ul>
</li>
</ul>
<h2 id="52-评估指标" tabindex="-1">5.2. 评估指标</h2>
<p id="para-52-评估指标-1" data-para-index="1" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标">论文使用了以下三个指标来评估 <code>KGeNT</code> 的有效性：</p>
<ol>
<li id="para-52-评估指标-2" data-para-index="2" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标">
<p><strong>准确率 (Accuracy, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>)</strong>:</p>
<ul>
<li id="para-52-评估指标-3" data-para-index="3" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="概念定义" data-para-sub-slug="概念定义" data-para-alias="para-52-评估指标--概念定义"><span id="para-52-评估指标--概念定义" data-anchor-alias="para-52-评估指标-3" style="position: relative; top: 0px;"></span><strong>概念定义</strong>: 表示 <code>KGeNT</code> 成功合成了<strong>正确实现用户提示功能</strong>的 <code>eBPF</code> 程序的百分比。这里的“正确”是通过<strong>手动检查 (manual inspection)</strong> 来确定的，因为同一个提示可能对应多种正确的实现方式。该指标衡量了系统生成可用程序的有效性。</li>
<li id="para-52-评估指标-4" data-para-index="4" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="数学公式" data-para-sub-slug="数学公式" data-para-alias="para-52-评估指标--数学公式"><span id="para-52-评估指标--数学公式" data-anchor-alias="para-52-评估指标-4" style="position: relative; top: 0px;"></span><strong>数学公式</strong>:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mtext>合成并验证通过的语义正确的程序数量</mtext><mtext>总提示数量</mtext></mfrac><mo>×</mo><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">
        A = \frac{\text{合成并验证通过的语义正确的程序数量}}{\text{总提示数量}} \times 100\%
        </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">总提示数量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">合成并验证通过的语义正确的程序数量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span></span></li>
<li id="para-52-评估指标-5" data-para-index="5" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="符号解释" data-para-sub-slug="符号解释" data-para-alias="para-52-评估指标--符号解释"><span id="para-52-评估指标--符号解释" data-anchor-alias="para-52-评估指标-5" style="position: relative; top: 0px;"></span><strong>符号解释</strong>:
<ul>
<li id="para-52-评估指标-6" data-para-index="6" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>: 准确率。</li>
<li id="para-52-评估指标-7" data-para-index="7" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标">合成并验证通过的语义正确的程序数量: 指 <code>KGeNT</code> 生成的 <code>eBPF</code> 程序通过了 <code>Symbolic Verifier</code> 和 <code>eBPF</code> Verifier 的所有检查，并且人工核实后确认其语义与用户提示完全一致。</li>
<li id="para-52-评估指标-8" data-para-index="8" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标">总提示数量: 指用于评估的所有自然语言提示的总数。</li>
</ul>
</li>
</ul>
</li>
<li id="para-52-评估指标-9" data-para-index="9" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标">
<p><strong>假阴性 (False Negatives, <code>FNs</code>)</strong>:</p>
<ul>
<li id="para-52-评估指标-10" data-para-index="10" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="概念定义" data-para-sub-slug="概念定义" data-para-alias="para-52-评估指标--概念定义"><strong>概念定义</strong>: 表示 <code>KGeNT</code> <strong>未能合成出经过验证的 <code>eBPF</code> 程序</strong>的提示百分比。这可能是因为 <code>KGeNT</code> 无法生成语法正确或通过验证器的程序，也可能是因为在达到最大迭代次数后仍未能成功。假阴性代表了一种<strong>活性违规 (liveness violation)</strong>，即开发者在面对这些提示时，无法使用 <code>KGeNT</code> 来完成任务。</li>
<li id="para-52-评估指标-11" data-para-index="11" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="数学公式" data-para-sub-slug="数学公式" data-para-alias="para-52-评估指标--数学公式"><strong>数学公式</strong>:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mi>N</mi><mi>s</mi><mo>=</mo><mfrac><mtext>未能合成出经过验证的程序数量</mtext><mtext>总提示数量</mtext></mfrac><mo>×</mo><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">
        FNs = \frac{\text{未能合成出经过验证的程序数量}}{\text{总提示数量}} \times 100\%
        </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">FN</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">总提示数量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">未能合成出经过验证的程序数量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span></span></li>
<li id="para-52-评估指标-12" data-para-index="12" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="符号解释" data-para-sub-slug="符号解释" data-para-alias="para-52-评估指标--符号解释"><strong>符号解释</strong>:
<ul>
<li id="para-52-评估指标-13" data-para-index="13" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标"><code>FNs</code>: 假阴性率。</li>
<li id="para-52-评估指标-14" data-para-index="14" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标">未能合成出经过验证的程序数量: 指 <code>KGeNT</code> 在所有迭代尝试后，仍未能生成一个既通过 <code>Symbolic Verifier</code> 又通过 <code>eBPF</code> Verifier 的 <code>eBPF</code> 程序。</li>
</ul>
</li>
</ul>
</li>
<li id="para-52-评估指标-15" data-para-index="15" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标">
<p><strong>假阳性 (False Positives, <code>FPs</code>)</strong>:</p>
<ul>
<li id="para-52-评估指标-16" data-para-index="16" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="概念定义" data-para-sub-slug="概念定义" data-para-alias="para-52-评估指标--概念定义"><strong>概念定义</strong>: 表示 <code>KGeNT</code> 合成了<strong>经过验证但实际上并未正确实现用户提示功能</strong>的 <code>eBPF</code> 程序的百分比。这意味着 <code>KGeNT</code> 内部的验证过程（<code>Symbolic Verifier</code> 和 <code>eBPF</code> Verifier）认为程序是正确的，但<strong>人工检查 (manual inspection)</strong> 却发现其语义与用户提示不符。假阳性代表了一种<strong>安全违规 (safety violation)</strong>，因为开发者可能会部署一个看似正确但功能错误的内核扩展，从而可能导致系统行为异常甚至安全隐患。</li>
<li id="para-52-评估指标-17" data-para-index="17" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="数学公式" data-para-sub-slug="数学公式" data-para-alias="para-52-评估指标--数学公式"><strong>数学公式</strong>:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mi>P</mi><mi>s</mi><mo>=</mo><mfrac><mtext>验证通过但语义不正确的程序数量</mtext><mtext>总提示数量</mtext></mfrac><mo>×</mo><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">
        FPs = \frac{\text{验证通过但语义不正确的程序数量}}{\text{总提示数量}} \times 100\%
        </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">FP</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">总提示数量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">验证通过但语义不正确的程序数量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span></span></li>
<li id="para-52-评估指标-18" data-para-index="18" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标" data-para-sub-title="符号解释" data-para-sub-slug="符号解释" data-para-alias="para-52-评估指标--符号解释"><strong>符号解释</strong>:
<ul>
<li id="para-52-评估指标-19" data-para-index="19" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标"><code>FPs</code>: 假阳性率。</li>
<li id="para-52-评估指标-20" data-para-index="20" data-para-heading="52-评估指标" data-para-heading-title="5.2. 评估指标">验证通过但语义不正确的程序数量: 指 <code>KGeNT</code> 生成的 <code>eBPF</code> 程序通过了 <code>Symbolic Verifier</code> 和 <code>eBPF</code> Verifier 的所有检查，但人工核实后发现其语义并未正确实现用户提示的功能。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="53-对比基线" tabindex="-1">5.3. 对比基线</h2>
<p id="para-53-对比基线-1" data-para-index="1" data-para-heading="53-对比基线" data-para-heading-title="5.3. 对比基线">为了评估 <code>KGeNT</code> 的有效性，研究者将其与以下基线模型进行了比较：</p>
<ul>
<li id="para-53-对比基线-2" data-para-index="2" data-para-heading="53-对比基线" data-para-heading-title="5.3. 对比基线" data-para-sub-title="GPT-4 few shot" data-para-sub-slug="gpt-4-few-shot" data-para-alias="para-53-对比基线--gpt-4-few-shot"><span id="para-53-对比基线--gpt-4-few-shot" data-anchor-alias="para-53-对比基线-2" style="position: relative; top: 0px;"></span><strong>GPT-4 few shot</strong>: 这是最基本的基线配置。它使用<strong>单次提示 (single prompting)</strong> 的 <code>GPT-4</code> 来合成 <code>eBPF</code> 程序，然后仅使用<strong>内置的 <code>eBPF</code> 验证器 (built-in eBPF verifier)</strong> 来验证输出。这种配置代表了不包含 <code>KGeNT</code> 复杂反馈循环和符号执行组件的简单 <code>LLM</code> 代码生成方法。</li>
<li id="para-53-对比基线-3" data-para-index="3" data-para-heading="53-对比基线" data-para-heading-title="5.3. 对比基线" data-para-sub-title="GPT-4+Feedback" data-para-sub-slug="gpt-4feedback" data-para-alias="para-53-对比基线--gpt-4feedback"><span id="para-53-对比基线--gpt-4feedback" data-anchor-alias="para-53-对比基线-3" style="position: relative; top: 0px;"></span><strong>GPT-4+Feedback</strong>: 在 <code>GPT-4 few shot</code> 的基础上，增加了 <code>KGeNT</code> 的<strong>模型引导反馈 (model-guided feedback)</strong> 机制。这意味着 <code>LLM</code> 会接收到来自验证器的错误信息，并有机会在后续迭代中修正其输出。</li>
<li id="para-53-对比基线-4" data-para-index="4" data-para-heading="53-对比基线" data-para-heading-title="5.3. 对比基线" data-para-sub-title="GPT-4+Feedback+Symbex" data-para-sub-slug="gpt-4feedbacksymbex" data-para-alias="para-53-对比基线--gpt-4feedbacksymbex"><span id="para-53-对比基线--gpt-4feedbacksymbex" data-anchor-alias="para-53-对比基线-4" style="position: relative; top: 0px;"></span><strong>GPT-4+Feedback+Symbex</strong>: 在 <code>GPT-4+Feedback</code> 的基础上，进一步包含了 <code>KGeNT</code> 的<strong>理解引擎 (Comprehension Engine)</strong> 和<strong>符号执行 (Symbolic Execution)</strong> 组件。此配置旨在展示 <code>KGeNT</code> 核心验证机制的效益。</li>
<li id="para-53-对比基线-5" data-para-index="5" data-para-heading="53-对比基线" data-para-heading-title="5.3. 对比基线" data-para-sub-title="Human Expertise (人类专业知识)" data-para-sub-slug="human-expertise-人类专业知识" data-para-alias="para-53-对比基线--human-expertise-人类专业知识"><span id="para-53-对比基线--human-expertise-人类专业知识" data-anchor-alias="para-53-对比基线-5" style="position: relative; top: 0px;"></span><strong>Human Expertise (人类专业知识)</strong>: 这是一个特殊的基线，旨在隔离 <code>KGeNT</code> 自动化推理的能力。研究者通过手动为 <code>EBPFNLDATAsET</code> 测试集中的每个提示补充正确的 <code>kprobe</code> 和 <code>kretprobe</code> 位置信息，然后将这个<strong>增强数据集 (augmented dataset)</strong> 作为输入提供给 <code>GPT-4+feedback+dataset</code> 基线（即上述 <code>GPT-4+Feedback+Symbex</code> 移除其自身理解和符号执行模块后的配置，但加入了数据集训练）。这个基线模拟了由人类专家提供关键上下文信息的情况。</li>
</ul>
<h1 id="6-实验结果与分析" tabindex="-1">6. 实验结果与分析</h1>
<h2 id="61-核心结果分析" tabindex="-1">6.1. 核心结果分析</h2>
<h3 id="611-kgent-的总体有效性" tabindex="-1">6.1.1. <code>KGeNT</code> 的总体有效性</h3>
<p id="para-611-kgent-的总体有效性-1" data-para-index="1" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性"><code>KGeNT</code> 的核心目标是提高 <code>eBPF</code> 程序合成的准确性并降低危险的假阳性率。实验结果有力地证明了 <code>KGeNT</code> 在这两个方面的显著优势。</p>
<p id="para-611-kgent-的总体有效性-2" data-para-index="2" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">下表（原文 Table 1）展示了不同配置下 <code>KGeNT</code> 的准确率 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>)、假阳性率 (<code>FP</code>) 和假阴性率 (<code>FN</code>)：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>System</th>
<th>A</th>
<th>FP</th>
<th>FN</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPT-4 few shot</td>
<td>30%</td>
<td>2.5%</td>
<td>67.5%</td>
</tr>
<tr>
<td>GPT-4+Feedback</td>
<td>60%</td>
<td>7.5%</td>
<td>32.5%</td>
</tr>
<tr>
<td>GPT-4+Feedback+Symbex</td>
<td>77.5%</td>
<td>5%</td>
<td>17.5%</td>
</tr>
<tr>
<td>Human Expertise</td>
<td>72.5%</td>
<td>2.5%</td>
<td>25%</td>
</tr>
<tr>
<td>KgeNT</td>
<td>80%</td>
<td>2.5%</td>
<td>17.5%</td>
</tr>
</tbody>
</table></div>
<p id="para-611-kgent-的总体有效性-3" data-para-index="3" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">Table 1: The Breakdown Accuracy Analysis of KGENT</p>
<p id="para-611-kgent-的总体有效性-4" data-para-index="4" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">从 <code>Table 1</code> 可以看出：</p>
<ul>
<li id="para-611-kgent-的总体有效性-5" data-para-index="5" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">
<p><strong>准确率 (A)</strong>: <code>KGeNT</code> 实现了 80% 的准确率，这比初始的 <code>GPT-4 few shot</code> 基线（30%）提高了 2.67 倍。这表明 <code>KGeNT</code> 能够更可靠地生成功能正确的 <code>eBPF</code> 程序。</p>
</li>
<li id="para-611-kgent-的总体有效性-6" data-para-index="6" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">
<p><strong>假阳性率 (FP)</strong>: <code>KGeNT</code> 的假阳性率仅为 2.5%，与 <code>GPT-4 few shot</code> 基线持平，但显著低于 <code>GPT-4+Feedback</code> 配置（7.5%）。低假阳性率对于内核扩展至关重要，因为它意味着 <code>KGeNT</code> 很少生成看似正确但实际功能错误的危险程序。</p>
</li>
<li id="para-611-kgent-的总体有效性-7" data-para-index="7" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">
<p><strong>假阴性率 (FN)</strong>: <code>KGeNT</code> 的假阴性率为 17.5%，是所有配置中最低的，这意味着它最少出现无法生成任何有效程序的情况。</p>
<p>下图中（原文 Figure 6）展示了 <code>KGeNT</code> (K) 和 <code>GPT-4</code> 基线 (C) 在每个提示上的有效性：</p>
<p><img src="/files/papers/6971fc30cfa1aabed60f2ed8/images/6.jpg" alt="Figure 6: The per-prompt effectiveness of KGeNt (K) and a GPT-4 (C). Each bar chart shows the percentage of time that KGEnt/GPT-4 synthesizes an accurate(red), false negative (pink), or false positive(grey) eBPF program for each prompt over ten trials." loading="lazy">
<em>该图像是图表，展示了 KGeNt (K) 与 GPT-4 (C) 在不同案例中生成准确（红色）、假阴性（粉色）和假阳性（灰色） eBPF 程序的比例。每组条形图对应不同的案例，结果由百分比表示。</em></p>
</li>
</ul>
<p id="para-611-kgent-的总体有效性-8" data-para-index="8" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">Figure 6: The per-prompt effectiveness of KGeNt (K) and a GPT-4 (C). Each bar chart shows the percentage of time that KGEnt/GPT-4 synthesizes an accurate(red), false negative (pink), or false positive(grey) eBPF program for each prompt over ten trials.</p>
<p id="para-611-kgent-的总体有效性-9" data-para-index="9" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">通过检查每个单独测试用例的结果，可以观察到：</p>
<ul>
<li id="para-611-kgent-的总体有效性-10" data-para-index="10" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">在 40 个测试用例中，<code>KGeNT</code> 在 37 个用例中生成正确程序的频率高于基线。</li>
<li id="para-611-kgent-的总体有效性-11" data-para-index="11" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">在 11 个测试用例中，<code>KGeNT</code> 的准确率提高了 9 倍以上（即基线准确率至多 10%，而 <code>KGeNT</code> 至少 90%）。</li>
<li id="para-611-kgent-的总体有效性-12" data-para-index="12" data-para-heading="611-kgent-的总体有效性" data-para-heading-title="6.1.1. KGeNT 的总体有效性">在出现假阳性的 9 个测试用例中，<code>KGeNT</code> 在 6 个用例中改善了假阳性率。这进一步强调了 <code>KGeNT</code> 在提高安全性和可靠性方面的能力。</li>
</ul>
<h2 id="62-数据呈现-表格" tabindex="-1">6.2. 数据呈现 (表格)</h2>
<p id="para-62-数据呈现-表格-1" data-para-index="1" data-para-heading="62-数据呈现-表格" data-para-heading-title="6.2. 数据呈现 (表格)">上面已经给出了原文 Table 1 和 Figure 6，并对其进行了详细分析。</p>
<h2 id="63-消融实验参数分析" tabindex="-1">6.3. 消融实验/参数分析</h2>
<h3 id="631-kgent-高层设计决策的有效性" tabindex="-1">6.3.1. <code>KGeNT</code> 高层设计决策的有效性</h3>
<p id="para-631-kgent-高层设计决策的有效性-1" data-para-index="1" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性"><code>Table 1</code> 详细展示了 <code>KGeNT</code> 各个高层设计决策对系统有效性的影响。从 <code>GPT-4 few shot</code> 基线开始，逐步加入 <code>KGeNT</code> 的设计特性，按照对准确率影响最大的顺序进行：</p>
<ol>
<li id="para-631-kgent-高层设计决策的有效性-2" data-para-index="2" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性" data-para-sub-title="GPT-4 few shot (基线)" data-para-sub-slug="gpt-4-few-shot-基线" data-para-alias="para-631-kgent-高层设计决策的有效性--gpt-4-few-shot-基线"><span id="para-631-kgent-高层设计决策的有效性--gpt-4-few-shot-基线" data-anchor-alias="para-631-kgent-高层设计决策的有效性-2" style="position: relative; top: 0px;"></span><strong>GPT-4 few shot (基线)</strong>: 准确率 30%，假阳性率 2.5%，假阴性率 67.5%。这表明单纯使用 <code>GPT-4</code> 进行少样本合成，效果不佳，多数情况下无法生成正确程序。</li>
<li id="para-631-kgent-高层设计决策的有效性-3" data-para-index="3" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性" data-para-sub-title="GPT-4+Feedback (加入模型引导反馈)" data-para-sub-slug="gpt-4feedback-加入模型引导反馈" data-para-alias="para-631-kgent-高层设计决策的有效性--gpt-4feedback-加入模型引导反馈"><span id="para-631-kgent-高层设计决策的有效性--gpt-4feedback-加入模型引导反馈" data-anchor-alias="para-631-kgent-高层设计决策的有效性-3" style="position: relative; top: 0px;"></span><strong>GPT-4+Feedback (加入模型引导反馈)</strong>:
<ul>
<li id="para-631-kgent-高层设计决策的有效性-4" data-para-index="4" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性" data-para-sub-title="模型引导反馈 (model-guided feedback)" data-para-sub-slug="模型引导反馈-model-guided-feedback" data-para-alias="para-631-kgent-高层设计决策的有效性--模型引导反馈-model-guided-feedback"><span id="para-631-kgent-高层设计决策的有效性--模型引导反馈-model-guided-feedback" data-anchor-alias="para-631-kgent-高层设计决策的有效性-4" style="position: relative; top: 0px;"></span>准确率从 30% 提高到 60%，提升了一倍。这表明<strong>模型引导反馈 (model-guided feedback)</strong> 在提高 <code>LLM</code> 代码合成准确性方面起到了重要作用。通过将验证失败的错误信息反馈给 <code>LLM</code>，<code>LLM</code> 能够迭代地修正其输出。</li>
<li id="para-631-kgent-高层设计决策的有效性-5" data-para-index="5" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性">然而，假阳性率从 2.5% 增加到 7.5%，增加了 3 倍。这提示单纯的反馈可能导致 <code>LLM</code> 在尝试通过验证时，会生成一些“看起来”通过验证但实际语义不符的程序。</li>
</ul>
</li>
<li id="para-631-kgent-高层设计决策的有效性-6" data-para-index="6" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性" data-para-sub-title="GPT-4+Feedback+Symbex (加入理解引擎和符号执行组件)" data-para-sub-slug="gpt-4feedbacksymbex-加入理解引擎和符号执行组件" data-para-alias="para-631-kgent-高层设计决策的有效性--gpt-4feedbacksymbex-加入理解引擎和符号执行组件"><span id="para-631-kgent-高层设计决策的有效性--gpt-4feedbacksymbex-加入理解引擎和符号执行组件" data-anchor-alias="para-631-kgent-高层设计决策的有效性-6" style="position: relative; top: 0px;"></span><strong>GPT-4+Feedback+Symbex (加入理解引擎和符号执行组件)</strong>:
<ul>
<li id="para-631-kgent-高层设计决策的有效性-7" data-para-index="7" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性">准确率进一步提高到 77.5%。这显著提升了系统的语义正确性。</li>
<li id="para-631-kgent-高层设计决策的有效性-8" data-para-index="8" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性" data-para-sub-title="理解引擎 (Comprehension Engine)" data-para-sub-slug="理解引擎-comprehension-engine" data-para-alias="para-631-kgent-高层设计决策的有效性--理解引擎-comprehension-engine"><span id="para-631-kgent-高层设计决策的有效性--理解引擎-comprehension-engine" data-anchor-alias="para-631-kgent-高层设计决策的有效性-8" style="position: relative; top: 0px;"></span>假阳性率降低到 5%。这表明<strong>理解引擎 (Comprehension Engine)</strong> 生成的 <code>Hoare</code> 逻辑注解和<strong>符号验证器 (Symbolic Verifier)</strong> 提供的严格语义检查，能够有效捕获并纠正 <code>LLM</code> 生成的语义不正确的程序，从而降低了假阳性率。</li>
</ul>
</li>
<li id="para-631-kgent-高层设计决策的有效性-9" data-para-index="9" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性" data-para-sub-title="KGeNT (最终系统，加入 EBPFNLDATAsET 数据集训练)" data-para-sub-slug="kgent-最终系统加入-ebpfnldataset-数据集训练" data-para-alias="para-631-kgent-高层设计决策的有效性--kgent-最终系统加入-ebpfnldataset-数据集训练"><span id="para-631-kgent-高层设计决策的有效性--kgent-最终系统加入-ebpfnldataset-数据集训练" data-anchor-alias="para-631-kgent-高层设计决策的有效性-9" style="position: relative; top: 0px;"></span><strong>KGeNT (最终系统，加入 <code>EBPFNLDATAsET</code> 数据集训练)</strong>:
<ul>
<li id="para-631-kgent-高层设计决策的有效性-10" data-para-index="10" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性">准确率略微提高 2.5% 至 80%。这表明使用 <code>EBPFNLDATAsET</code> 数据集进行训练对准确率的直接影响相对较小。</li>
<li id="para-631-kgent-高层设计决策的有效性-11" data-para-index="11" data-para-heading="631-kgent-高层设计决策的有效性" data-para-heading-title="6.3.1. KGeNT 高层设计决策的有效性" data-para-sub-title="大幅下降" data-para-sub-slug="大幅下降" data-para-alias="para-631-kgent-高层设计决策的有效性--大幅下降"><span id="para-631-kgent-高层设计决策的有效性--大幅下降" data-anchor-alias="para-631-kgent-高层设计决策的有效性-11" style="position: relative; top: 0px;"></span>然而，假阳性率<strong>大幅下降</strong>回基线的 2.5%。这说明 <code>EBPFNLDATAsET</code> 数据集在训练 <code>LLM</code> 识别和避免生成语义错误的程序方面发挥了关键作用，即便在增加了反馈和符号执行之后，它仍然能够进一步优化模型的输出，使其更安全可靠。</li>
</ul>
</li>
</ol>
<h3 id="632-kgent-理解和符号执行引擎的有效性" tabindex="-1">6.3.2. <code>KGeNT</code> 理解和符号执行引擎的有效性</h3>
<p id="para-632-kgent-理解和符号执行引擎的有效性-1" data-para-index="1" data-para-heading="632-kgent-理解和符号执行引擎的有效性" data-para-heading-title="6.3.2. KGeNT 理解和符号执行引擎的有效性">为了量化 <code>KGeNT</code> 自动化推理（理解和符号执行引擎）的价值，实验设计了一个<strong>人类专业知识 (Human Expertise)</strong> 基线。该基线通过人工为测试集中的每个提示补充正确的 <code>kprobe</code> 和 <code>kretprobe</code> 位置（这通常需要人类内核专家的知识），然后将其输入到 <code>GPT-4+feedback+dataset</code> 基线中。</p>
<ul>
<li id="para-632-kgent-理解和符号执行引擎的有效性-2" data-para-index="2" data-para-heading="632-kgent-理解和符号执行引擎的有效性" data-para-heading-title="6.3.2. KGeNT 理解和符号执行引擎的有效性">
<p><strong>结果对比</strong>:</p>
<ul>
<li id="para-632-kgent-理解和符号执行引擎的有效性-3" data-para-index="3" data-para-heading="632-kgent-理解和符号执行引擎的有效性" data-para-heading-title="6.3.2. KGeNT 理解和符号执行引擎的有效性"><code>Human Expertise</code> 基线：准确率 72.5%，假阳性率 2.5%，假阴性率 25%。</li>
<li id="para-632-kgent-理解和符号执行引擎的有效性-4" data-para-index="4" data-para-heading="632-kgent-理解和符号执行引擎的有效性" data-para-heading-title="6.3.2. KGeNT 理解和符号执行引擎的有效性"><code>KGeNT</code>：准确率 80%，假阳性率 2.5%，假阴性率 17.5%。</li>
</ul>
</li>
<li id="para-632-kgent-理解和符号执行引擎的有效性-5" data-para-index="5" data-para-heading="632-kgent-理解和符号执行引擎的有效性" data-para-heading-title="6.3.2. KGeNT 理解和符号执行引擎的有效性">
<p><strong>分析</strong>: <code>KGeNT</code> 在没有直接提供人类专业知识的情况下，其准确率甚至高于人类专业知识基线，且假阳性率保持一致。这表明 <code>KGeNT</code> 的<strong>反馈循环 (feedback loop)</strong>（在每次符号执行失败时启动）为合成引擎提供了足够的知识，以取代基线中人类专家所提供的洞察力。这揭示了 <code>KGeNT</code> 的反馈机制与自动化推理功能之间强大的<strong>协同效应 (synergy)</strong>。<code>LLM</code> 生成的程序和 <code>Hoare</code> 逻辑注解，结合符号执行的严格验证，并通过反馈机制不断完善，最终能够超越单纯依赖人类预设知识的系统。</p>
</li>
</ul>
<h3 id="633-使用-bpftrace-而非-libbpf-的有效性" tabindex="-1">6.3.3. 使用 <code>bpftrace</code> 而非 <code>libbpf</code> 的有效性</h3>
<p id="para-633-使用-bpftrace-而非-libbpf-的有效性-1" data-para-index="1" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性">实验比较了使用 <code>bpftrace</code> 和 <code>libbpf</code> 作为 <code>eBPF</code> 程序合成目标的效果：</p>
<ul>
<li id="para-633-使用-bpftrace-而非-libbpf-的有效性-2" data-para-index="2" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性">
<p><strong>灵活性与复杂性</strong>: <code>libbpf</code> 虽然提供了更大的灵活性，但也引入了更高的编程复杂性。</p>
</li>
<li id="para-633-使用-bpftrace-而非-libbpf-的有效性-3" data-para-index="3" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性">
<p><strong>符号执行问题</strong>: 由于 <code>libbpf</code> 程序中频繁使用<strong>辅助函数 (helper function)</strong> 导致<strong>状态爆炸 (state explosion)</strong> 问题，<code>KGeNT</code> 的符号执行引擎很少能在 <code>libbpf</code> 程序上终止。</p>
</li>
<li id="para-633-使用-bpftrace-而非-libbpf-的有效性-4" data-para-index="4" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性">
<p><strong>性能对比</strong>:</p>
<ul>
<li id="para-633-使用-bpftrace-而非-libbpf-的有效性-5" data-para-index="5" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性">当不使用 <code>KGeNT</code> 的理解和符号执行引擎时：
<ul>
<li id="para-633-使用-bpftrace-而非-libbpf-的有效性-6" data-para-index="6" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性"><code>libbpf</code> 程序的准确率为 37.5%。</li>
<li id="para-633-使用-bpftrace-而非-libbpf-的有效性-7" data-para-index="7" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性"><code>bpftrace</code> 程序的准确率为 60%。</li>
</ul>
</li>
<li id="para-633-使用-bpftrace-而非-libbpf-的有效性-8" data-para-index="8" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性">合成时间：<code>libbpf</code> 程序平均需要 2.16 秒合成，而 <code>bpftrace</code> 程序只需 1 秒。</li>
</ul>
</li>
<li id="para-633-使用-bpftrace-而非-libbpf-的有效性-9" data-para-index="9" data-para-heading="633-使用-bpftrace-而非-libbpf-的有效性" data-para-heading-title="6.3.3. 使用 bpftrace 而非 libbpf 的有效性">
<p><strong>结论</strong>: 鉴于上述结果，研究者得出结论：对于 <code>KGeNT</code> 的 <code>eBPF</code> 用例，<code>bpftrace</code> 是一个更好的合成目标。其相对较低的复杂性使得符号执行更容易成功，从而提高了整体合成的准确性和效率。</p>
</li>
</ul>
<h1 id="7-总结与思考" tabindex="-1">7. 总结与思考</h1>
<h2 id="71-结论总结" tabindex="-1">7.1. 结论总结</h2>
<p id="para-71-结论总结-1" data-para-index="1" data-para-heading="71-结论总结" data-para-heading-title="7.1. 结论总结">本文提出了 <strong>KGeNT</strong>，一个创新的系统，旨在帮助开发者通过使用<strong>自然语言 (natural language)</strong> 扩展其内核的 <code>eBPF</code> 功能。<code>KGeNT</code> 的核心在于其独特的组合：它将<strong>大语言模型 (LLM)</strong> 的<strong>程序合成 (program synthesis)</strong> 能力和<strong>程序理解 (program comprehension)</strong> 能力与<strong>符号执行 (symbolic execution)</strong> 的严格验证机制相结合。通过一个<strong>反馈驱动的迭代过程 (feedback-driven iterative process)</strong>，<code>KGeNT</code> 能够从用户提示中合成 <code>eBPF</code> 程序，利用 <code>LLM</code> 为内核函数生成 <code>Hoare</code> 逻辑契约，并通过符号执行验证程序的语义正确性。实验结果表明，<code>KGeNT</code> 实现了 80% 的程序合成准确率，比现有 <code>GPT-4</code> 基线提高了 2.67 倍，并且保持了极低的 2.5% 假阳性率，这对于内核级代码的安全性至关重要。此外，论文还贡献了两个宝贵的数据集：<code>EBPFNLDATAsET</code> 和 <code>KERNELCoMPDATAsET</code>，为未来的 <code>eBPF</code> 程序合成研究提供了基础。</p>
<h2 id="72-局限性与未来工作" tabindex="-1">7.2. 局限性与未来工作</h2>
<ul>
<li id="para-72-局限性与未来工作-1" data-para-index="1" data-para-heading="72-局限性与未来工作" data-para-heading-title="7.2. 局限性与未来工作" data-para-sub-title="性能与可用性" data-para-sub-slug="性能与可用性" data-para-alias="para-72-局限性与未来工作--性能与可用性"><span id="para-72-局限性与未来工作--性能与可用性" data-anchor-alias="para-72-局限性与未来工作-1" style="position: relative; top: 0px;"></span><strong>性能与可用性</strong>: 未来工作将涉及增强 <code>KGeNT</code> 的整体性能和可用性，以使其更易于广泛采用和部署。</li>
<li id="para-72-局限性与未来工作-2" data-para-index="2" data-para-heading="72-局限性与未来工作" data-para-heading-title="7.2. 局限性与未来工作" data-para-sub-title="数据集扩展" data-para-sub-slug="数据集扩展" data-para-alias="para-72-局限性与未来工作--数据集扩展"><span id="para-72-局限性与未来工作--数据集扩展" data-anchor-alias="para-72-局限性与未来工作-2" style="position: relative; top: 0px;"></span><strong>数据集扩展</strong>: 将继续扩展 <code>KGeNT</code> 的数据集，以覆盖更广泛的 <code>eBPF</code> 用例和内核函数，进一步提升系统的泛化能力。</li>
<li id="para-72-局限性与未来工作-3" data-para-index="3" data-para-heading="72-局限性与未来工作" data-para-heading-title="7.2. 局限性与未来工作" data-para-sub-title="实际应用探索" data-para-sub-slug="实际应用探索" data-para-alias="para-72-局限性与未来工作--实际应用探索"><span id="para-72-局限性与未来工作--实际应用探索" data-anchor-alias="para-72-局限性与未来工作-3" style="position: relative; top: 0px;"></span><strong>实际应用探索</strong>: 探索 <code>KGeNT</code> 在真实世界中的应用，进一步推动 <code>eBPF</code> 程序合成技术的发展。</li>
<li id="para-72-局限性与未来工作-4" data-para-index="4" data-para-heading="72-局限性与未来工作" data-para-heading-title="7.2. 局限性与未来工作" data-para-sub-title="libbpf 的挑战" data-para-sub-slug="libbpf-的挑战" data-para-alias="para-72-局限性与未来工作--libbpf-的挑战"><span id="para-72-局限性与未来工作--libbpf-的挑战" data-anchor-alias="para-72-局限性与未来工作-4" style="position: relative; top: 0px;"></span><strong><code>libbpf</code> 的挑战</strong>: 论文指出，<code>libbpf</code> 程序由于其更高的编程复杂性和频繁使用辅助函数导致<strong>状态爆炸 (state explosion)</strong>，使得符号执行引擎在其上很少终止。这限制了 <code>KGeNT</code> 对更复杂 <code>eBPF</code> 场景（通常需要 <code>libbpf</code> 的灵活性）的适用性。未来可能需要研究更高效的符号执行技术或为 <code>libbpf</code> 特性进行专门优化。</li>
<li id="para-72-局限性与未来工作-5" data-para-index="5" data-para-heading="72-局限性与未来工作" data-para-heading-title="7.2. 局限性与未来工作" data-para-sub-title="LLM 依赖" data-para-sub-slug="llm-依赖" data-para-alias="para-72-局限性与未来工作--llm-依赖"><span id="para-72-局限性与未来工作--llm-依赖" data-anchor-alias="para-72-局限性与未来工作-5" style="position: relative; top: 0px;"></span><strong><code>LLM</code> 依赖</strong>: <code>KGeNT</code> 目前默认使用 <code>GPT-4 API</code>。虽然这展示了最先进 <code>LLM</code> 的能力，但也意味着对外部服务的依赖（成本、隐私、可用性）。未来可能需要探索如何使其在开源 <code>LLM</code> 上也能保持高效，或者开发更轻量级的专用 <code>LLM</code>。</li>
<li id="para-72-局限性与未来工作-6" data-para-index="6" data-para-heading="72-局限性与未来工作" data-para-heading-title="7.2. 局限性与未来工作" data-para-sub-title="平台限制" data-para-sub-slug="平台限制" data-para-alias="para-72-局限性与未来工作--平台限制"><span id="para-72-局限性与未来工作--平台限制" data-anchor-alias="para-72-局限性与未来工作-6" style="position: relative; top: 0px;"></span><strong>平台限制</strong>: 当前 <code>KGeNT</code> 原型仅在 Linux 上运行，限制了其适用范围。扩展对 Windows <code>eBPF</code> 的支持将是重要的未来方向。</li>
</ul>
<h2 id="73-个人启发与批判" tabindex="-1">7.3. 个人启发与批判</h2>
<h3 id="731-个人启发" tabindex="-1">7.3.1. 个人启发</h3>
<p id="para-731-个人启发-1" data-para-index="1" data-para-heading="731-个人启发" data-para-heading-title="7.3.1. 个人启发">这篇论文提供了一个非常重要的启发，即<strong>将大语言模型 (LLM) 的生成能力与形式化验证的严格性相结合，是解决代码生成领域“正确性”和“安全性”挑战的强大途径</strong>。以往 <code>LLM</code> 生成代码的质量问题一直是部署到生产环境的障碍，而 <code>KGeNT</code> 通过引入多级验证（<code>Hoare</code> 逻辑、符号执行、<code>eBPF</code> 验证器）和反馈循环，大大提升了生成代码的可靠性，特别是在内核扩展这种对错误零容忍的场景中。这种“生成-验证-反馈”的范式值得在其他关键软件开发领域推广。</p>
<p id="para-731-个人启发-2" data-para-index="2" data-para-heading="731-个人启发" data-para-heading-title="7.3.1. 个人启发">另一个启发是<strong>自动化数据集生成的潜力</strong>。<code>KERNELCoMPDATAsET</code> 通过结合正则表达式和 <code>LLM</code> 来自动生成内核函数的 <code>Hoare</code> 逻辑契约，这展示了如何利用 <code>LLM</code> 来解决传统形式化验证中最大的障碍之一——手动创建验证规范的巨大工作量。这种方法有望加速形式化验证在复杂系统中的应用。</p>
<h3 id="732-批判" tabindex="-1">7.3.2. 批判</h3>
<ul>
<li id="para-732-批判-1" data-para-index="1" data-para-heading="732-批判" data-para-heading-title="7.3.2. 批判" data-para-sub-title="符号执行的局限性" data-para-sub-slug="符号执行的局限性" data-para-alias="para-732-批判--符号执行的局限性"><span id="para-732-批判--符号执行的局限性" data-anchor-alias="para-732-批判-1" style="position: relative; top: 0px;"></span><strong>符号执行的局限性</strong>: 论文明确提到了符号执行在处理 <code>libbpf</code> 程序时面临的“状态爆炸”问题，导致其很少终止。这表明尽管 <code>KGeNT</code> 在 <code>bpftrace</code> 上表现出色，但其核心的验证机制在面对更复杂的 <code>eBPF</code> 程序（通常由 <code>libbpf</code> 编写）时，效率和可行性会大打折扣。这限制了 <code>KGeNT</code> 在 <code>eBPF</code> 全领域内的普适性。如何克服符号执行的扩展性瓶颈，尤其是在 <code>eBPF</code> 这种带有复杂内核 API 调用的场景中，是一个长期挑战。</li>
<li id="para-732-批判-2" data-para-index="2" data-para-heading="732-批判" data-para-heading-title="7.3.2. 批判" data-para-sub-title="KERNELCoMPDATAsET 的准确性假设" data-para-sub-slug="kernelcompdataset-的准确性假设" data-para-alias="para-732-批判--kernelcompdataset-的准确性假设"><span id="para-732-批判--kernelcompdataset-的准确性假设" data-anchor-alias="para-732-批判-2" style="position: relative; top: 0px;"></span><strong><code>KERNELCoMPDATAsET</code> 的准确性假设</strong>: <code>KERNELCoMPDATAsET</code> 的生成依赖于从内核函数注释中“近似语义”并输入给 <code>LLM</code> 生成 <code>Z3</code> 条件。虽然论文提到“尚未需要修复不准确之处”，但这并不意味着其总是完全准确。如果原始注释不完整、模糊或过时，或者 <code>LLM</code> 对其理解有误，生成的 <code>Hoare</code> 逻辑契约就可能存在缺陷，从而可能导致符号验证器在错误规范下“成功”验证了语义不正确的程序。这种“<strong>元验证 (meta-verification)</strong>”的准确性至关重要，但其可靠性仍需更严格的评估。</li>
<li id="para-732-批判-3" data-para-index="3" data-para-heading="732-批判" data-para-heading-title="7.3.2. 批判" data-para-sub-title="用户干预的必要性" data-para-sub-slug="用户干预的必要性" data-para-alias="para-732-批判--用户干预的必要性"><span id="para-732-批判--用户干预的必要性" data-anchor-alias="para-732-批判-3" style="position: relative; top: 0px;"></span><strong>用户干预的必要性</strong>: 论文提到当 <code>KGeNT</code> 失败时，系统会重新提示用户提供“额外的语义提示（例如，变量的预期大小）”来解决问题。这暗示了在某些复杂情况下，<code>LLM</code> 仍然无法完全从自然语言提示中捕获所有必要的语义信息，需要人类以更结构化或更具体的语言进行干预。这在一定程度上削弱了“自然语言编写内核扩展”的无缝体验，并对用户提出了额外的专业知识要求。</li>
<li id="para-732-批判-4" data-para-index="4" data-para-heading="732-批判" data-para-heading-title="7.3.2. 批判" data-para-sub-title="评估指标的局限性" data-para-sub-slug="评估指标的局限性" data-para-alias="para-732-批判--评估指标的局限性"><span id="para-732-批判--评估指标的局限性" data-anchor-alias="para-732-批判-4" style="position: relative; top: 0px;"></span><strong>评估指标的局限性</strong>: 准确率、假阳性率和假阴性率的评估依赖于“手动检查”来确定程序的语义正确性。虽然这在研究阶段是常见的做法，但在大规模部署时，手动检查的成本和主观性可能会成为问题。如何进一步自动化或形式化语义正确性的判断，以提高评估效率和客观性，将是重要研究方向。</li>
</ul>
</div></div></div></div>